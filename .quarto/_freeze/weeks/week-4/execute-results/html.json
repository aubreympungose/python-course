{
  "hash": "3ae68983aa61cfabb3a774bddf488d63",
  "result": {
    "markdown": "---\ntitle: \"5 Data Manipulation Part 2\"\ncode-copy: true\ncode-line-numbers: true\ntidy: true\ncode-annotations: below\n---\n\n\nLast week we introduced the basics of data manipulation using `dplyr`. This week I want u to continue to intermediate data manipulation in `dplyr`. \n\n\n## 5.1 Renaming columns\n\nYou will notice that the column names in the `gapminder` dataset do not follow *tidy* principles. Naming things in a *tidy* we follow these principles:\n\n- No spaces between characters\n\n- all names should be in lower cases\n\n- only use underscore (_) to separate characters.\n\nThe [tidyverse style guide](https://style.tidyverse.org/). In our columns, the column names `lifeExp` are `gdpPercap` need to be renamed. We will use `rename()` function within `dplyr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Load tidyverse\n\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\n### load the data\n\ngapminder <- gapminder::gapminder\n\ngapminder$country <- as.character(gapminder$country)\n\ngapminder$continent <- as.character(gapminder$continent)\n```\n:::\n\n\nthen use `rename()` to change column names; we will save the new dataframe as `gapminder_new`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_new <- gapminder |> \n  rename(life_expectancy = lifeExp,\n         gdp_per_capita = gdpPercap)\n\nhead(gapminder_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country     continent  year life_expectancy      pop gdp_per_capita\n  <chr>       <chr>     <int>           <dbl>    <int>          <dbl>\n1 Afghanistan Asia       1952            28.8  8425333           779.\n2 Afghanistan Asia       1957            30.3  9240934           821.\n3 Afghanistan Asia       1962            32.0 10267083           853.\n4 Afghanistan Asia       1967            34.0 11537966           836.\n5 Afghanistan Asia       1972            36.1 13079460           740.\n6 Afghanistan Asia       1977            38.4 14880372           786.\n```\n:::\n:::\n\n\nThe dataframe is updated with changed column names. However, when working with data with many columns, it would be time consuming to change each column. Fortunately, within the package `janitor` there is function called `clean_names` that change all the column names into a tidy way. Install the janitor package first:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"janitor\")\n```\n:::\n\n\nAfter install it load it: and use the `clean_names()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'janitor'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n```\n:::\n\n```{.r .cell-code}\ngapminder_new <- clean_names(gapminder)\n\nhead(gapminder_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  country     continent  year life_exp      pop gdp_percap\n  <chr>       <chr>     <int>    <dbl>    <int>      <dbl>\n1 Afghanistan Asia       1952     28.8  8425333       779.\n2 Afghanistan Asia       1957     30.3  9240934       821.\n3 Afghanistan Asia       1962     32.0 10267083       853.\n4 Afghanistan Asia       1967     34.0 11537966       836.\n5 Afghanistan Asia       1972     36.1 13079460       740.\n6 Afghanistan Asia       1977     38.4 14880372       786.\n```\n:::\n:::\n\n\nSee that untidy column names were changed automatically.\n\n## 5.2 Converting column data types\n\nRemember we discussed 3 data types:\n\n- character\n\n- numeric\n\n- logical\n\nIn a dataframe, you can find the data type of the column by using `class()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(gapminder$country)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(gapminder$gdpPercap)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nYou can also use the `str()` to find the data types of all columns in the dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n```\n:::\n:::\n\n\nSometimes you may find that the all values in a column would be saved as character when they are supposed to be numeric. You can change them as using `as.numeric()` function. Let us simulate some fake data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngender <- c(\"male\", \"female\", \"female\", \"male\", \"female\")\n\nage <- c(\"18\", \"30\", \"45\", \"21\", \"54\")\n\nexample_df <- data.frame(gender, age)\n\nexample_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n```\n:::\n:::\n\n\nIn the example_df dataframe, you can see that the age column has been stored as character, which doesn't make any sense:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(example_df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n```\n:::\n:::\n\n\nConvert this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df$age <- as.numeric(example_df$age)\n\nstr(example_df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n num [1:5] 18 30 45 21 54\n```\n:::\n:::\n\n\nIf you want to convert it back to character, you can use `as.character()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample_df$age <- as.character(example_df$age)\n\nstr(example_df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n```\n:::\n:::\n\n\nThe only time this will not work is when you try to convert a character column such as `gender` into numeric; try it. Experiment with converting various column type with the gapminder dataset.\n\n### 5.2.1 Factors\n\nThere is another data type we have not discussed: factors or what may be called categorical data. Factors are like characters, except that they have integers that correspond to characters. In our example_df dataframe, we may want to make the column gender a factor, where 1 = male, 2 = female.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(example_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n```\n:::\n\n```{.r .cell-code}\nexample_df$gender <- factor(example_df$gender, levels = c(\"male\", \"female\"))\n\nstr(example_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t5 obs. of  2 variables:\n $ gender: Factor w/ 2 levels \"male\",\"female\": 1 2 2 1 2\n $ age   : chr  \"18\" \"30\" \"45\" \"21\" ...\n```\n:::\n:::\n\n\nThe gender column has been changed to factor, with 2 levels. \n\nLet us try to change the continent column in the gapminder dataset, we will try the `dplyr` method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder <- gapminder |> \n  mutate(continent_factor = factor(continent))\n\nstr(gapminder$continent_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n```\n:::\n:::\n\nHere we have used `mutate()` to create a new column named `continent_factor` that is a factor. It has 5 levels, you can check this using the `levels()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(gapminder$continent_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\" \n```\n:::\n:::\n\n\nCreating new columns instead of changing the existing one is important in some instances, especially when you want to compare the data. \n\nThe [`focrcats` package](https://forcats.tidyverse.org/) within `Tidyverse` was specifically create for factors, you may want to visit it to learn more about factors. \n\n## 5.3 Create a new categorical column from a numeric column\n\nIn many cases, we may want to create a new categorical column that takes the conditions from a numeric column. For example, example, in the following ages:\n\n- 1-12 = child\n\n- 13-17 = adolescent\n\n- 18-34 = young adults\n\n- 35-55 = adults\n\n- Over 55 = older adults\n\nWe can use the `case_when()` function within `mutate()` to create this column. Let us generate some fake data;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(45)\n###simulate a character vector with a length of 50\ngender <- sample(c(\"male\", \"female\"), size = 50, replace = T, prob = c(.45, .55))\n\n\n## simulate a numeric vector, with a length of 50, from ages 1 to 75\nage <- sample(1:75, size = 50)\n\nfake_df <- tibble(gender, age)\n\nhead(fake_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  gender   age\n  <chr>  <int>\n1 male      18\n2 female    11\n3 female    55\n4 female    62\n5 female    67\n6 female    27\n```\n:::\n:::\n\n\nThen compute a new column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfake_df <- fake_df |> \n  mutate(age_group = case_when(\n    age >= 1 & age <=12 ~ \"child\",\n    age >= 13 & age <= 17 ~ \"adolescent\",\n    age >= 18 & age <= 34 ~ \"young adult\",\n    age >= 35 & age <= 55 ~ \"adult\",\n    age > 55 ~ \"older adult\"\n  ))\n\nfake_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 50 × 3\n   gender   age age_group  \n   <chr>  <int> <chr>      \n 1 male      18 young adult\n 2 female    11 child      \n 3 female    55 adult      \n 4 female    62 older adult\n 5 female    67 older adult\n 6 female    27 young adult\n 7 female    41 adult      \n 8 male       6 child      \n 9 female    10 child      \n10 female    51 adult      \n# ℹ 40 more rows\n```\n:::\n:::\n\n\nPlot the new column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfake_df |> \n  ggplot(aes(x = age_group)) +\n  geom_bar() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](week-4_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nWe have created a new column called `age_group` using the age column. \n\nExperiment with the gapminder data. We may want to group countries according to their life expectancy based on the following rules:\n\n- if life expectancy of a country is lower than the world average, we will classify it as 'low life expectancy'\n\n- if life expectancy of a country is higher than the world average, we will classify it as 'high life expectancy'\n\nWe will only use observations from the year 2007:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 <- gapminder |> \n  filter(year == 2007)\n```\n:::\n\n\nCreate a new column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 <- gapminder_2007 |> \n  mutate(life_expect_category = case_when(\n    lifeExp < mean(lifeExp) ~ 'low life expectancy',\n    lifeExp > mean(lifeExp) ~ 'high life expectancy'\n  ))\n```\n:::\n\n\nWe have created added a new column called `life_expect_category`; plot this column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngapminder_2007 |> \n  ggplot(aes(x = life_expect_category)) +\n  geom_bar() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](week-4_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n### 5.4 Missing data\n\nData rarely comes clean, and sometimes data can contain missing value. In R missing values are stored as `NA`. Once we go to the introduction to  statistics section, we will deal with missing values.\n\n\n### 5.5 Reshaping data\n\nThere are 2 types of dataframes: wide and long formats. I will use examples to illustrate both types. \n\nSuppose we have data containing GDP increase rate of South Africa from 2010 to 2020 Let us create a _long_ format of this dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyear <- c(2010:2020)\n  \ngdp_rate <- c(2.8, 3.1, 3.3, 2.2, 1.9, 1.3, 1.5, 0.6, 0.8, 0.2, -7.0)\n\nsa_gdp_long <- data.frame(year, gdp_rate)\n\nsa_gdp_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   year gdp_rate\n1  2010      2.8\n2  2011      3.1\n3  2012      3.3\n4  2013      2.2\n5  2014      1.9\n6  2015      1.3\n7  2016      1.5\n8  2017      0.6\n9  2018      0.8\n10 2019      0.2\n11 2020     -7.0\n```\n:::\n:::\n\n\nThe dataframe is in long format: We have one column reprenting all years, and gdp_rate column representing all values of GDP growth rate. What if we want to change to a _wide_ format? We can use `pivot_wider()` function within `tidyr` package, also a part of `tydiverse`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsa_gdp_wide <- pivot_wider(sa_gdp_long,  names_from = year, values_from = gdp_rate)\n\nsa_gdp_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 11\n  `2010` `2011` `2012` `2013` `2014` `2015` `2016` `2017` `2018` `2019` `2020`\n   <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1    2.8    3.1    3.3    2.2    1.9    1.3    1.5    0.6    0.8    0.2     -7\n```\n:::\n:::\n\n\nYou can see that in a wide format, each year is a column.\n\n### 5.5.1 Excercise\n\nIn the gapminder data do the following:\n\n- Select country, year and life expectancy columns\n\n- filter rows rows from South Africa, Zimbabwe and Mozambique\n\n- reshape this data to a wide format\n\n## 5.6 Joining data\n\nYou my have 2 dataframes with corresponding ID columns but with other different column names. Create a first dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry_name <- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(187)\npopulation <- sample(5000:15000, 7)\n\npop_df <- data.frame(country_name, population)\n\npop_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country_name population\n1 South Africa       7330\n2     Zimbabwe      11323\n3   Mozambique       7419\n4     Botswana       9156\n5     Eswatini      11783\n6      Lesotho      14088\n7      Namibia       8824\n```\n:::\n:::\n\n\nCreate a second dataframe:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncountry_name <- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(50)\navg_age <- sample(23:35, 7)\n\nage_df <- data.frame(country_name, avg_age)\n\nage_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country_name avg_age\n1 South Africa      33\n2     Zimbabwe      26\n3   Mozambique      24\n4     Botswana      29\n5     Eswatini      25\n6      Lesotho      30\n7      Namibia      34\n```\n:::\n:::\n\n\nNow we have 2 data frames: pop_df with a fake data on countries' population and the age_df with a fake data on countries' average age. The common name in both dataframes is `country_name`. We will use `merge()` function to join 2 dataframes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_df <- merge(pop_df, age_df, by = \"country_name\")\n\ncombined_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  country_name population avg_age\n1     Botswana       9156      29\n2     Eswatini      11783      25\n3      Lesotho      14088      30\n4   Mozambique       7419      24\n5      Namibia       8824      34\n6 South Africa       7330      33\n7     Zimbabwe      11323      26\n```\n:::\n:::\n\n\nBingo!\n\nThere is more to joining data: `merge()` is a Base R funcion. There are other options of joining data using `dplyr`; see [this guide](https://dplyr.tidyverse.org/reference/mutate-joins.html)\n\n\n\n\n\n\n",
    "supporting": [
      "week-4_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}