[
  {
    "objectID": "weeks/week-6.html",
    "href": "weeks/week-6.html",
    "title": "Communicating and Reporting with Quarto",
    "section": "",
    "text": "This week I would like to introduce you to writing reproducible reports using Quarto, a next generation ‚Äúopen-source scientific and technical publishing system‚Äù. It is an integrated ecosystem, where you can integrate your code, reports, figures, references, tables etc. in one environment. With Quarto you can write:\n\nBooks (examples include: R for Data Science, Second dition; Python for Data Analysis Hands-On Programming with R)\nReproducible journal papers: (some examples: Elsevier Template, )\nWebsite: This website is written with Quarto, hosted in GitHub all for free\nPresentations: (examples: This presentation)\nDynamic reports\nBlogs: personal, work etc. (examples: )\n\nAnd more! See examples on the Quarto website\nQuarto can render documents in multiple formats, including HTML, PDF, word formats, etc."
  },
  {
    "objectID": "weeks/week-6.html#introduction-to-quarto",
    "href": "weeks/week-6.html#introduction-to-quarto",
    "title": "Communicating and Reporting with Quarto",
    "section": "",
    "text": "This week I would like to introduce you to writing reproducible reports using Quarto, a next generation ‚Äúopen-source scientific and technical publishing system‚Äù. It is an integrated ecosystem, where you can integrate your code, reports, figures, references, tables etc. in one environment. With Quarto you can write:\n\nBooks (examples include: R for Data Science, Second dition; Python for Data Analysis Hands-On Programming with R)\nReproducible journal papers: (some examples: Elsevier Template, )\nWebsite: This website is written with Quarto, hosted in GitHub all for free\nPresentations: (examples: This presentation)\nDynamic reports\nBlogs: personal, work etc. (examples: )\n\nAnd more! See examples on the Quarto website\nQuarto can render documents in multiple formats, including HTML, PDF, word formats, etc."
  },
  {
    "objectID": "weeks/week-6.html#how-does-quarto-work",
    "href": "weeks/week-6.html#how-does-quarto-work",
    "title": "Communicating and Reporting with Quarto",
    "section": "5.2 How does Quarto Work?",
    "text": "5.2 How does Quarto Work?\nFor all my writing, I have shifted from what Kieran Healy calls the ‚ÄúOffice Model‚Äù to an ‚ÄúEngineering Model‚Äù:\n\nOffice solutions tend towards a cluster of tools where something like Microsoft Word is at the center of your work. A Word file or set of files is the most ‚Äúreal‚Äù thing in your project. Changes to your work are tracked inside that file or files. Citation and reference managers plug into those files. The outputs of data analyses‚Äîtables, figures‚Äîget cut and pasted in as well, or are kept alongside them. The master document may be passed around from person to person to be edited and updated.4 The final output is exported from it, perhaps to PDF or to HTML, but maybe most often the final output just is the .docx file, cleaned up and with the track changes feature turned off.\n\n\nIn the Engineering model, meanwhile, plain text files are at the center of your work. The most ‚Äúreal‚Äù thing in your project will either be those files or, more likely, the version control repository that stores the project. Changes are tracked outside of files, again using a version control system. Data analysis is managed in code that produces outputs in (ideally) a known and reproducible manner. Citation and reference management will likely also be done in plain text, as with a BibTeX .bib file. Final outputs are assembled from the plain text and turned to .tex, .html, or .pdf using some kind of typesetting or conversion tool. Very often, because of some unavoidable facts about the world, the final output of this kind of solution is also a .docx file.\n\nQuarto then is the part of the ‚Äúengineering model‚Äù. It mainly uses Markdown format for writing. ‚ÄúMarkdown is a lightweight markup language that you can use to add formatting elements to plaintext text documents‚Äù."
  },
  {
    "objectID": "weeks/week-6.html#lets-practice",
    "href": "weeks/week-6.html#lets-practice",
    "title": "Communicating and Reporting with Quarto",
    "section": "5.3 Let‚Äôs Practice",
    "text": "5.3 Let‚Äôs Practice\nYou will need the following:\n\nR and RStudio (or any IDE such as VSCode etc)\nQuarto: If you are using RStudio, Quarto is already installed. If you using other IDEs such as VSCode, download and install Quarto from the Quarto website\nZotero: For references bibliography and citations. Download and install Zotero from Zotero website\nBetter BibTeX (BBT): BBT is a Zotero extension that manages things like citation keys. You can download BBT from: https://retorque.re/zotero-better-bibtex/.\n\nAll these tools are open source and available for free!\n5.3.1 Openning Quarto\nFirst create a directory/folder where you will save all the files. For example I will create a folder named ‚Äúintro_to_quarto‚Äù in my documents directory. This is where you will store all your files.\nIn RStudio, go to FILE -&gt; New File -&gt; Quarto Document\nOn the pop-up window, just select ‚ÄúCreate Empty Document‚Äù. A blank Quarto page will be open:\n\nSave the document to folder that you have created\n5.3.2 YAMl\nThe first part of the page is know as YAML, it contains the information about the document, this include:\n\nQuarto YML Options\n\n\n\n\n\nOption\nDescription\n\n\n\ntitle\ntittle of the document\n\n\nsubtitle\nsubtitle of the document\n\n\nauthor\nAuthor\n\n\ndate\ndate of the document was published\n\n\nformat\noutput of the document: options include html, docx, pdf, etc\n\n\ntoc\ntable of contents\n\n\nnumber-sections\nAutomatically number headings and sections\n\n\nbibliography\na file containing references\n\n\ncsl\nreferencing style\n\n\n\n\n\n\n\nThere are many other options that you can use to customise your document; you can a complete guide here. Let us experiment with few options.\nLook how I have customised my yaml:\n\nExperiment with other options. Please not that this must be should start with ‚Äî and end with ‚Äî.\n5.3.3 Writing using Markdown\nHeadings\nYou insert headings by using # at the beginning of a sentence:\n\n\nSource: Quarto\n\nUpdate your document by including headings as follows:\n---\ntitle: \"Introduction to Quarto\"\nsubtitle: \"Writing Reproducible Documents wih Quarto andd RStudio\"\nauthor: \"Aubrey Mpungose\"\ndate: 04 June 2023\ndate-format: \"DD MMMM YYYY\"\nformat:\n  html:\n    toc: true\n---\n\n# Section 1\n\n\n## Section 1.1 \n\n\n### Section 1.1.1 \n\n\n#### Section 1.1.1.1\n\n\n##### Other section\n\n\n###### Other section\nSave and render the document by clicking on the ‚ÄúRender‚Äù option as highlighted on the image below\n\nFormating texts\n\n\nQuarto website\n\nUpdate your document as the following and render the document, obviously your name is not Aubrey Mpungose:\n---\ntitle: \"Introduction to Quarto\"\nsubtitle: \"Writing Reproducible Documents wih Quarto andd RStudio\"\nauthor: \"Aubrey Mpungose\"\ndate: 04 June 2019\ndate-format: \"DD MMMM YYYY\"\nformat:\n  html:\n    toc: true\n---\n\n# 1. Italics\n\nMy name is *Aubrey Mpungose*, I love doing *data science*\n\nI can also format text in _italics_\n\n# 2. Bold \n\nThis is how I format text into **BOLD**\n\n\n# 3. Bold and Italics\n\nI can also format text to be ***Bold and Italic***\n\n\n# 4. Example\n\nMy name is *Aubrey Mpungose*, I love doing _data science_. Some people think markdown syntax is difficult,  but it is not: for example, I can make text to be **Bold**. I can also format text format text to be ***bold and italic***\nThe output will be the following:\n\nFigures/Images\nLet‚Äôs say you have an image named meerkat.png in your folder, update your document with the following:\n\nInsert a picture from the web\n\n![A meerkat](meerkat.png)\nThis will inclde the meerkat image in the document. Note that inside [] is the caption, in my case, ‚ÄúA meerkat‚Äù. You must put parentheses () after with no spaces.\n\n\nA meerkat\n\nThere are other options for figures including width, length, etc. You can find more from Quarto website.\nComputation and code\nYou can include R, Python, Javascript and other programming languages code within quarto document. We will show some examples using R and gapminder data that we have been using. For example, to insert R code, you insert a code chunk begining with {r} and ends with\nTo load the gapminder data and the tidyverse package, insert the following and render the document:\n\nYou can also label code chunks:\n\nThere are many code chunk options that you can include depending on your needs.\nFigures\nYou can insert figures within quarto document:\n\n\n\n\n\n\nInsert tables\nThe gt package has beautiful table formats. install the package first:\n\ninstall.packages(\"gt\")\n\nThen Run the following code:\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\nJapan\nAsia\n2007\n82.603\n127467972\n31656.07\n\n\nHong Kong, China\nAsia\n2007\n82.208\n6980412\n39724.98\n\n\nIceland\nEurope\n2007\n81.757\n301931\n36180.79\n\n\nSwitzerland\nEurope\n2007\n81.701\n7554661\n37506.42\n\n\nAustralia\nOceania\n2007\n81.235\n20434176\n34435.37\n\n\nSpain\nEurope\n2007\n80.941\n40448191\n28821.06\n\n\nSweden\nEurope\n2007\n80.884\n9031088\n33859.75\n\n\nIsrael\nAsia\n2007\n80.745\n6426679\n25523.28\n\n\nFrance\nEurope\n2007\n80.657\n61083916\n30470.02\n\n\nCanada\nAmericas\n2007\n80.653\n33390141\n36319.24\n\n\n\n\n\n\nYou can also customise your tables to include title, subtitle and rename column names\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  arrange(desc(lifeExp)) |&gt; \n  head(10) |&gt; \n  gt() |&gt; \n  tab_header(title = md(\"**Highest Life Expectancy**\")) |&gt; \n  cols_label(country = md(\"**Country**\"),\n             continent = md(\"**Continent**\"),\n             year = md(\"**Year**\"),\n             lifeExp = md(\"**Life expectancy**\"),\n             pop = md(\"**Population**\"),\n             gdpPercap = md(\"**GDP per capita**\"))\n\n\n\n\n\n\nHighest Life Expectancy\n    \n\nCountry\n      Continent\n      Year\n      Life expectancy\n      Population\n      GDP per capita\n    \n\n\nJapan\nAsia\n2007\n82.603\n127467972\n31656.07\n\n\nHong Kong, China\nAsia\n2007\n82.208\n6980412\n39724.98\n\n\nIceland\nEurope\n2007\n81.757\n301931\n36180.79\n\n\nSwitzerland\nEurope\n2007\n81.701\n7554661\n37506.42\n\n\nAustralia\nOceania\n2007\n81.235\n20434176\n34435.37\n\n\nSpain\nEurope\n2007\n80.941\n40448191\n28821.06\n\n\nSweden\nEurope\n2007\n80.884\n9031088\n33859.75\n\n\nIsrael\nAsia\n2007\n80.745\n6426679\n25523.28\n\n\nFrance\nEurope\n2007\n80.657\n61083916\n30470.02\n\n\nCanada\nAmericas\n2007\n80.653\n33390141\n36319.24\n\n\n\n\n\n\nNote that we included md(** **) to specify that this is a markdown syntax and we want to make text bold.\nI will explain how include citations and bibliography in class."
  },
  {
    "objectID": "weeks/week-4.html",
    "href": "weeks/week-4.html",
    "title": "5 Data Manipulation Part 2",
    "section": "",
    "text": "Last week we introduced the basics of data manipulation using dplyr. This week I want u to continue to intermediate data manipulation in dplyr."
  },
  {
    "objectID": "weeks/week-4.html#renaming-columns",
    "href": "weeks/week-4.html#renaming-columns",
    "title": "5 Data Manipulation Part 2",
    "section": "5.1 Renaming columns",
    "text": "5.1 Renaming columns\nYou will notice that the column names in the gapminder dataset do not follow tidy principles. Naming things in a tidy we follow these principles:\n\nNo spaces between characters\nall names should be in lower cases\nonly use underscore (_) to separate characters.\n\nThe tidyverse style guide. In our columns, the column names lifeExp are gdpPercap need to be renamed. We will use rename() function within dplyr:\n\n### Load tidyverse\n\nlibrary(tidyverse)\n\n‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.2 ‚îÄ‚îÄ\n‚úî ggplot2 3.4.1     ‚úî purrr   1.0.1\n‚úî tibble  3.1.8     ‚úî dplyr   1.1.0\n‚úî tidyr   1.3.0     ‚úî stringr 1.5.0\n‚úî readr   2.1.4     ‚úî forcats 1.0.0\n‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n‚úñ dplyr::filter() masks stats::filter()\n‚úñ dplyr::lag()    masks stats::lag()\n\n### load the data\n\ngapminder &lt;- gapminder::gapminder\n\ngapminder$country &lt;- as.character(gapminder$country)\n\ngapminder$continent &lt;- as.character(gapminder$continent)\n\nthen use rename() to change column names; we will save the new dataframe as gapminder_new\n\ngapminder_new &lt;- gapminder |&gt; \n  rename(life_expectancy = lifeExp,\n         gdp_per_capita = gdpPercap)\n\nhead(gapminder_new)\n\n# A tibble: 6 √ó 6\n  country     continent  year life_expectancy      pop gdp_per_capita\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;           &lt;dbl&gt;    &lt;int&gt;          &lt;dbl&gt;\n1 Afghanistan Asia       1952            28.8  8425333           779.\n2 Afghanistan Asia       1957            30.3  9240934           821.\n3 Afghanistan Asia       1962            32.0 10267083           853.\n4 Afghanistan Asia       1967            34.0 11537966           836.\n5 Afghanistan Asia       1972            36.1 13079460           740.\n6 Afghanistan Asia       1977            38.4 14880372           786.\n\n\nThe dataframe is updated with changed column names. However, when working with data with many columns, it would be time consuming to change each column. Fortunately, within the package janitor there is function called clean_names that change all the column names into a tidy way. Install the janitor package first:\n\ninstall.packages(\"janitor\")\n\nAfter install it load it: and use the clean_names() function:\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\ngapminder_new &lt;- clean_names(gapminder)\n\nhead(gapminder_new)\n\n# A tibble: 6 √ó 6\n  country     continent  year life_exp      pop gdp_percap\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;      &lt;dbl&gt;\n1 Afghanistan Asia       1952     28.8  8425333       779.\n2 Afghanistan Asia       1957     30.3  9240934       821.\n3 Afghanistan Asia       1962     32.0 10267083       853.\n4 Afghanistan Asia       1967     34.0 11537966       836.\n5 Afghanistan Asia       1972     36.1 13079460       740.\n6 Afghanistan Asia       1977     38.4 14880372       786.\n\n\nSee that untidy column names were changed automatically."
  },
  {
    "objectID": "weeks/week-4.html#converting-column-data-types",
    "href": "weeks/week-4.html#converting-column-data-types",
    "title": "5 Data Manipulation Part 2",
    "section": "5.2 Converting column data types",
    "text": "5.2 Converting column data types\nRemember we discussed 3 data types:\n\ncharacter\nnumeric\nlogical\n\nIn a dataframe, you can find the data type of the column by using class() function\n\nclass(gapminder$country)\n\n[1] \"character\"\n\nclass(gapminder$gdpPercap)\n\n[1] \"numeric\"\n\n\nYou can also use the str() to find the data types of all columns in the dataframe:\n\nstr(gapminder)\n\ntibble [1,704 √ó 6] (S3: tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nSometimes you may find that the all values in a column would be saved as character when they are supposed to be numeric. You can change them as using as.numeric() function. Let us simulate some fake data:\n\ngender &lt;- c(\"male\", \"female\", \"female\", \"male\", \"female\")\n\nage &lt;- c(\"18\", \"30\", \"45\", \"21\", \"54\")\n\nexample_df &lt;- data.frame(gender, age)\n\nexample_df\n\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n\n\nIn the example_df dataframe, you can see that the age column has been stored as character, which doesn‚Äôt make any sense:\n\nstr(example_df$age)\n\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n\n\nConvert this:\n\nexample_df$age &lt;- as.numeric(example_df$age)\n\nstr(example_df$age)\n\n num [1:5] 18 30 45 21 54\n\n\nIf you want to convert it back to character, you can use as.character() function:\n\nexample_df$age &lt;- as.character(example_df$age)\n\nstr(example_df$age)\n\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n\n\nThe only time this will not work is when you try to convert a character column such as gender into numeric; try it. Experiment with converting various column type with the gapminder dataset.\n5.2.1 Factors\nThere is another data type we have not discussed: factors or what may be called categorical data. Factors are like characters, except that they have integers that correspond to characters. In our example_df dataframe, we may want to make the column gender a factor, where 1 = male, 2 = female.\n\nhead(example_df)\n\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n\nexample_df$gender &lt;- factor(example_df$gender, levels = c(\"male\", \"female\"))\n\nstr(example_df)\n\n'data.frame':   5 obs. of  2 variables:\n $ gender: Factor w/ 2 levels \"male\",\"female\": 1 2 2 1 2\n $ age   : chr  \"18\" \"30\" \"45\" \"21\" ...\n\n\nThe gender column has been changed to factor, with 2 levels.\nLet us try to change the continent column in the gapminder dataset, we will try the dplyr method:\n\ngapminder &lt;- gapminder |&gt; \n  mutate(continent_factor = factor(continent))\n\nstr(gapminder$continent_factor)\n\n Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n\n\nHere we have used mutate() to create a new column named continent_factor that is a factor. It has 5 levels, you can check this using the levels() function:\n\nlevels(gapminder$continent_factor)\n\n[1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\" \n\n\nCreating new columns instead of changing the existing one is important in some instances, especially when you want to compare the data.\nThe focrcats package within Tidyverse was specifically create for factors, you may want to visit it to learn more about factors."
  },
  {
    "objectID": "weeks/week-4.html#create-a-new-categorical-column-from-a-numeric-column",
    "href": "weeks/week-4.html#create-a-new-categorical-column-from-a-numeric-column",
    "title": "5 Data Manipulation Part 2",
    "section": "5.3 Create a new categorical column from a numeric column",
    "text": "5.3 Create a new categorical column from a numeric column\nIn many cases, we may want to create a new categorical column that takes the conditions from a numeric column. For example, example, in the following ages:\n\n1-12 = child\n13-17 = adolescent\n18-34 = young adults\n35-55 = adults\nOver 55 = older adults\n\nWe can use the case_when() function within mutate() to create this column. Let us generate some fake data;\n\nset.seed(45)\n###simulate a character vector with a length of 50\ngender &lt;- sample(c(\"male\", \"female\"), size = 50, replace = T, prob = c(.45, .55))\n\n\n## simulate a numeric vector, with a length of 50, from ages 1 to 75\nage &lt;- sample(1:75, size = 50)\n\nfake_df &lt;- tibble(gender, age)\n\nhead(fake_df)\n\n# A tibble: 6 √ó 2\n  gender   age\n  &lt;chr&gt;  &lt;int&gt;\n1 male      18\n2 female    11\n3 female    55\n4 female    62\n5 female    67\n6 female    27\n\n\nThen compute a new column:\n\nfake_df &lt;- fake_df |&gt; \n  mutate(age_group = case_when(\n    age &gt;= 1 & age &lt;=12 ~ \"child\",\n    age &gt;= 13 & age &lt;= 17 ~ \"adolescent\",\n    age &gt;= 18 & age &lt;= 34 ~ \"young adult\",\n    age &gt;= 35 & age &lt;= 55 ~ \"adult\",\n    age &gt; 55 ~ \"older adult\"\n  ))\n\nfake_df\n\n# A tibble: 50 √ó 3\n   gender   age age_group  \n   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;      \n 1 male      18 young adult\n 2 female    11 child      \n 3 female    55 adult      \n 4 female    62 older adult\n 5 female    67 older adult\n 6 female    27 young adult\n 7 female    41 adult      \n 8 male       6 child      \n 9 female    10 child      \n10 female    51 adult      \n# ‚Ñπ 40 more rows\n\n\nPlot the new column:\n\nfake_df |&gt; \n  ggplot(aes(x = age_group)) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\nWe have created a new column called age_group using the age column.\nExperiment with the gapminder data. We may want to group countries according to their life expectancy based on the following rules:\n\nif life expectancy of a country is lower than the world average, we will classify it as ‚Äòlow life expectancy‚Äô\nif life expectancy of a country is higher than the world average, we will classify it as ‚Äòhigh life expectancy‚Äô\n\nWe will only use observations from the year 2007:\n\ngapminder_2007 &lt;- gapminder |&gt; \n  filter(year == 2007)\n\nCreate a new column:\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(life_expect_category = case_when(\n    lifeExp &lt; mean(lifeExp) ~ 'low life expectancy',\n    lifeExp &gt; mean(lifeExp) ~ 'high life expectancy'\n  ))\n\nWe have created added a new column called life_expect_category; plot this column:\n\ngapminder_2007 |&gt; \n  ggplot(aes(x = life_expect_category)) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\n5.4 Missing data\nData rarely comes clean, and sometimes data can contain missing value. In R missing values are stored as NA. Once we go to the introduction to statistics section, we will deal with missing values.\n5.5 Reshaping data\nThere are 2 types of dataframes: wide and long formats. I will use examples to illustrate both types.\nSuppose we have data containing GDP increase rate of South Africa from 2010 to 2020 Let us create a long format of this dataframe:\n\nyear &lt;- c(2010:2020)\n  \ngdp_rate &lt;- c(2.8, 3.1, 3.3, 2.2, 1.9, 1.3, 1.5, 0.6, 0.8, 0.2, -7.0)\n\nsa_gdp_long &lt;- data.frame(year, gdp_rate)\n\nsa_gdp_long\n\n   year gdp_rate\n1  2010      2.8\n2  2011      3.1\n3  2012      3.3\n4  2013      2.2\n5  2014      1.9\n6  2015      1.3\n7  2016      1.5\n8  2017      0.6\n9  2018      0.8\n10 2019      0.2\n11 2020     -7.0\n\n\nThe dataframe is in long format: We have one column reprenting all years, and gdp_rate column representing all values of GDP growth rate. What if we want to change to a wide format? We can use pivot_wider() function within tidyr package, also a part of tydiverse:\n\nsa_gdp_wide &lt;- pivot_wider(sa_gdp_long,  names_from = year, values_from = gdp_rate)\n\nsa_gdp_wide\n\n# A tibble: 1 √ó 11\n  `2010` `2011` `2012` `2013` `2014` `2015` `2016` `2017` `2018` `2019` `2020`\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1    2.8    3.1    3.3    2.2    1.9    1.3    1.5    0.6    0.8    0.2     -7\n\n\nYou can see that in a wide format, each year is a column.\n5.5.1 Excercise\nIn the gapminder data do the following:\n\nSelect country, year and life expectancy columns\nfilter rows rows from South Africa, Zimbabwe and Mozambique\nreshape this data to a wide format"
  },
  {
    "objectID": "weeks/week-4.html#joining-data",
    "href": "weeks/week-4.html#joining-data",
    "title": "5 Data Manipulation Part 2",
    "section": "5.6 Joining data",
    "text": "5.6 Joining data\nYou my have 2 dataframes with corresponding ID columns but with other different column names. Create a first dataframe:\n\ncountry_name &lt;- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(187)\npopulation &lt;- sample(5000:15000, 7)\n\npop_df &lt;- data.frame(country_name, population)\n\npop_df\n\n  country_name population\n1 South Africa       7330\n2     Zimbabwe      11323\n3   Mozambique       7419\n4     Botswana       9156\n5     Eswatini      11783\n6      Lesotho      14088\n7      Namibia       8824\n\n\nCreate a second dataframe:\n\ncountry_name &lt;- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(50)\navg_age &lt;- sample(23:35, 7)\n\nage_df &lt;- data.frame(country_name, avg_age)\n\nage_df\n\n  country_name avg_age\n1 South Africa      33\n2     Zimbabwe      26\n3   Mozambique      24\n4     Botswana      29\n5     Eswatini      25\n6      Lesotho      30\n7      Namibia      34\n\n\nNow we have 2 data frames: pop_df with a fake data on countries‚Äô population and the age_df with a fake data on countries‚Äô average age. The common name in both dataframes is country_name. We will use merge() function to join 2 dataframes:\n\ncombined_df &lt;- merge(pop_df, age_df, by = \"country_name\")\n\ncombined_df\n\n  country_name population avg_age\n1     Botswana       9156      29\n2     Eswatini      11783      25\n3      Lesotho      14088      30\n4   Mozambique       7419      24\n5      Namibia       8824      34\n6 South Africa       7330      33\n7     Zimbabwe      11323      26\n\n\nBingo!\nThere is more to joining data: merge() is a Base R funcion. There are other options of joining data using dplyr; see this guide"
  },
  {
    "objectID": "weeks/week-2.html",
    "href": "weeks/week-2.html",
    "title": "3 Data Visualisation",
    "section": "",
    "text": "Data visualisation is an important skill for data scientists. In fact, data manipulation and visualisations go hand in hand. Before any analysis, it is important to visualise data to explore its distribution, relationships, normality, etc.\nWe will be working with matplotlib library within Python for data visualistion. Although there are many other packages, matplotlib is the foundational library. Thus it is important to master matplotlib first before exploring other advanced libraries. You can import matplotlib as follows. We will also need the pandas package to read data:\n\nimport matplotlib.pyplot as plt\n\nimport pandas as pd\n\nWe will be working with the gapminder dataset, which is the real world data. I have saved this data as a CSV (comma-separated values) file on GitHub. A CSV file is a text file used to store data in a tabular format. You will use .read_csv() function from pandas to read this file and assign it to gapminder:\n\ngapminder = pd.read_csv(\"https://raw.githubusercontent.com/aubreympungose/data-science-course/main/weeks/data/gapminder.csv\")\n\n# Take a look at the first observation of the data\ngapminder.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nWe have loaded the dataset. You can see columns and rows.\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nWe can see that gapminder has 6 columns and 1704 rows. The columns in the dataset are:\n\ncountry: Simply the country\ncontinent: Continent\nyear: The year data was collected\nlifeExp: Life expectancy of a country in year\npop: Population of the country in a year\ngdpPercap: Gross Domestic Product of a country in a year\n\nIt is a time series data that track countries. Look at the range of years:\n\nprint(gapminder[\"year\"].min())\n\nprint(gapminder[\"year\"].max())\n\n1952\n2007\n\n\nThe datasets contain observations collected from 1952 to 2007.\n\n\nSuppose you want to show relationship between life expectancy and GDP per capita. We can create a scatterplot:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\nplt.show()\n\n\n\n\nWe have created a first plot. Let examine the code above:\n\nWe used scatter() function from pylot sub-package of matplotlib\nWe specified that we need the to plot two columns: gdpPercap on x-axis and lifeExp on the y-axis.\nWe then used .show() function from pyplot to show the plot.\n\n\n\n\nNotice that our first plot does not have any labels on the both axis, and also does not have a title. We can add all of these:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\n# Set x-axis labels \nplt.xlabel('GDP per capita')\n\n# Set y-axis\nplt.ylabel('Life expectancy')\n\n# set title of the plot\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\n# show the plot\n\nplt.show()\n\n\n\n\n\n\n\nNotice that x-axis is not normally distributed. One of the method to use is to transform data to log10, to normnalise it:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\nplt.xlabel('GDP per capita')\n\nplt.ylabel('Life expectancy')\n\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\n# Apply log scale to x-axis\nplt.xscale('log')\n\n\nplt.show()\n\n\n\n\n\n\n\nSometimes you may need to change how variables/data point appear. Suppose you want to make all the countries belonging to each continent to be of same colour. Here, you would need to create a dictionary where each continent name is a key and colour as a value, then create a plot\n\ncolour_dict = {\n    'Asia':'red',\n    'Europe':'green',\n    'Africa':'blue',\n    'Americas':'yellow',\n    'Oceania':'black'\n}\n\ncolors = [colour_dict[continent] for continent in gapminder['continent']]\n\nplt.scatter(gapminder['gdpPercap'], gapminder['lifeExp'], c=colors)\n\nplt.xlabel('GDP per capita')\n\nplt.ylabel('Life expectancy')\n\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\nplt.xscale('log')\n\n\nplt.show()"
  },
  {
    "objectID": "weeks/week-2.html#introduction-to-data-visualisation",
    "href": "weeks/week-2.html#introduction-to-data-visualisation",
    "title": "3 Data Visualisation",
    "section": "",
    "text": "Data visualisation is an important skill for data scientists. In fact, data manipulation and visualisations go hand in hand. Before any analysis, it is important to visualise data to explore its distribution, relationships, normality, etc.\nWe will be working with matplotlib library within Python for data visualistion. Although there are many other packages, matplotlib is the foundational library. Thus it is important to master matplotlib first before exploring other advanced libraries. You can import matplotlib as follows. We will also need the pandas package to read data:\n\nimport matplotlib.pyplot as plt\n\nimport pandas as pd\n\nWe will be working with the gapminder dataset, which is the real world data. I have saved this data as a CSV (comma-separated values) file on GitHub. A CSV file is a text file used to store data in a tabular format. You will use .read_csv() function from pandas to read this file and assign it to gapminder:\n\ngapminder = pd.read_csv(\"https://raw.githubusercontent.com/aubreympungose/data-science-course/main/weeks/data/gapminder.csv\")\n\n# Take a look at the first observation of the data\ngapminder.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nWe have loaded the dataset. You can see columns and rows.\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nWe can see that gapminder has 6 columns and 1704 rows. The columns in the dataset are:\n\ncountry: Simply the country\ncontinent: Continent\nyear: The year data was collected\nlifeExp: Life expectancy of a country in year\npop: Population of the country in a year\ngdpPercap: Gross Domestic Product of a country in a year\n\nIt is a time series data that track countries. Look at the range of years:\n\nprint(gapminder[\"year\"].min())\n\nprint(gapminder[\"year\"].max())\n\n1952\n2007\n\n\nThe datasets contain observations collected from 1952 to 2007.\n\n\nSuppose you want to show relationship between life expectancy and GDP per capita. We can create a scatterplot:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\nplt.show()\n\n\n\n\nWe have created a first plot. Let examine the code above:\n\nWe used scatter() function from pylot sub-package of matplotlib\nWe specified that we need the to plot two columns: gdpPercap on x-axis and lifeExp on the y-axis.\nWe then used .show() function from pyplot to show the plot.\n\n\n\n\nNotice that our first plot does not have any labels on the both axis, and also does not have a title. We can add all of these:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\n# Set x-axis labels \nplt.xlabel('GDP per capita')\n\n# Set y-axis\nplt.ylabel('Life expectancy')\n\n# set title of the plot\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\n# show the plot\n\nplt.show()\n\n\n\n\n\n\n\nNotice that x-axis is not normally distributed. One of the method to use is to transform data to log10, to normnalise it:\n\nplt.scatter(x = gapminder[\"gdpPercap\"], y = gapminder[\"lifeExp\"])\n\nplt.xlabel('GDP per capita')\n\nplt.ylabel('Life expectancy')\n\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\n# Apply log scale to x-axis\nplt.xscale('log')\n\n\nplt.show()\n\n\n\n\n\n\n\nSometimes you may need to change how variables/data point appear. Suppose you want to make all the countries belonging to each continent to be of same colour. Here, you would need to create a dictionary where each continent name is a key and colour as a value, then create a plot\n\ncolour_dict = {\n    'Asia':'red',\n    'Europe':'green',\n    'Africa':'blue',\n    'Americas':'yellow',\n    'Oceania':'black'\n}\n\ncolors = [colour_dict[continent] for continent in gapminder['continent']]\n\nplt.scatter(gapminder['gdpPercap'], gapminder['lifeExp'], c=colors)\n\nplt.xlabel('GDP per capita')\n\nplt.ylabel('Life expectancy')\n\nplt.title('GDP vs Life Expectancy (1952-2007)')\n\nplt.xscale('log')\n\n\nplt.show()"
  },
  {
    "objectID": "weeks/week-1a.html",
    "href": "weeks/week-1a.html",
    "title": "Introduction to Python Programming",
    "section": "",
    "text": "understand the basics of Python programming\nUnderstand data types and objects\nunderstand Python functions"
  },
  {
    "objectID": "weeks/week-1a.html#learning-objectives",
    "href": "weeks/week-1a.html#learning-objectives",
    "title": "Introduction to Python Programming",
    "section": "",
    "text": "understand the basics of Python programming\nUnderstand data types and objects\nunderstand Python functions"
  },
  {
    "objectID": "weeks/week-1a.html#reading",
    "href": "weeks/week-1a.html#reading",
    "title": "Introduction to Python Programming",
    "section": "Reading",
    "text": "Reading"
  },
  {
    "objectID": "weeks/week-1a.html#basics-of-python",
    "href": "weeks/week-1a.html#basics-of-python",
    "title": "Introduction to Python Programming",
    "section": "Basics of Python",
    "text": "Basics of Python\nIn the previous section, we showed the layout of RStudio. For this lesson, you will write all the code in the scripts/source and see the output in the console. To comment on the code, you will use the hashtag (#) to tell R not to execute the line as a code.\nR can be used as a calculator:\n\nprint(4 + 7) \n\nprint(9 * 6) \n\n11\n54\n\n\n\nArithmetic Operators\n\n\n\nDescription\nOperator\nExample\n\n\n\n\nAddition\n+\n1 + 3\n\n\nSubtract\n-\n90 - 5\n\n\nMultiplication\n*\n6 * 7\n\n\nExponentiation\n**\n3 ^ 6\n\n\nDivision\n/\n54 / 7\n\n\n\nType in and run the above examples in the script or console.\n\n\nAssigning variables\nNotice that we have been running previous codes without assigning them to a variable. We can assign anything to a variable (=); this can be a plot, a variable, a table, etc.\nSay we ages of two individuals: Thembi‚Äôs age is 30 and Sipho‚Äôs age is 20. You can assign their ages to a variable:\n\nthembi_age = 30\n\nsipho_age = 20\n\nYou can use print() function to get the results\n\nprint(thembi_age)\n\nprint(sipho_age)\n\n30\n20\n\n\nBecause you have stored/assigned these into variables, you can calculate, let‚Äôs say, total, differences, multiplication, etc. Get the sum of ages:\n\nsipho_age + thembi_age\n\n50\n\n\nGet age differences:\n\nthembi_age - sipho_age\n\n10\n\n\nMultiply these ages:\n\nthembi_age * sipho_age\n\n600\n\n\nBasically, we have crated variables: sipho_age and thembi_age, and stored their ages in numbers there. always remember this:\n\na variable name is case sensitive: if you have named it sipho_age, when you type Sipho_age there will be an error:\n\n\nprint(Sipho_age)\n\nNameError: name 'Sipho_age' is not defined\n\n\n\n\nData types in Python\nWhile there many data types in Python, in this course, we will focus on the most common:\nThere 3 basic data types in R\n\nnumeric:\n\nint: integers eg. (1, 2, 6, 90)\nfloat: with decimal e.g.¬†(1.2, 5.3, 8.4)\n\nstring: str. This is text data, for axample, ‚ÄúMy name is Aubrey‚Äù\nboolean: bool. TRUE/FALSE\n\n\nStrings\nStrings are character data types, alwways surrounded by quoates: either single quotes ('') or double quotes (\"\")\nExample of a string variables:\n\nriver = \"Tugela river\"\n\nprint(river)\n\nTugela river\n\n\n\ncountry  = \"South Africa\"\n\nprint(country)\n\nSouth Africa\n\n\nNotice that a string need to be surrounded by (‚Äú‚Äú) every time, otherwise Python will return an error\n\nriver = Tugela_river\n\nNameError: name 'Tugela_river' is not defined\n\n\nThere are various basic analysis we can apply to string. For example, you may add two string:\n\nname = \"Peter\"\n\nsurname = \"Zulu\"\n\n### Add to strings\n\nprint(name + surname)\n\nPeterZulu\n\n\nYou can leave spaces between when adding two string variables:\n\nprint(name + \" \" + surname)\n\nPeter Zulu\n\n\nYou can convert to strings to upper or lower cases by using .upper() and .lower() functions, respectively:\n\nname.upper() \n\n'PETER'\n\n\n\nsurname.lower()\n\n'zulu'\n\n\nHow long is the string? You can find out by using len() function:\n\nlen(name)\n\n5\n\n\n\nlen(surname)\n\n4\n\n\n\n\nNumeric data\nNumeric data represent numerical values, they can be either:\n\ninterger: whole numbers (e.g.¬†1, 30, 5, 90) or\nfloat: numbers with decimals (e.g.¬†1.2, 4.7‚Ä¶)\n\nFor example we may create a variables of river lenght and depth in kilometers\n\nriver_length_km = 531\nprint(river_length_km)\n\nriver_depth_km = 0.15\nprint(river_depth_km)\n\n531\n0.15\n\n\nThere are many functions that can be used to analyse numeric data, for example, we may add two numeric variables:\n\nprint(river_length_km + river_depth_km)\n\n531.15\n\n\nYou can multiply:\n\nprint(river_depth_km * river_depth_km)\n\n0.0225\n\n\nNumeric data does not to need to be surrounded by \" \", if you do, they will be stored as a string.\n\n\n\nBoolean\nBoolean data takes two possible values:True or False. An example of a logical data type:\n\nis_male = True\n\nprint(is_male) \n\nis_female = False\n\nprint(is_female) \n\nTrue\nFalse\n\n\nIn many cases, booleans are used to evaluate conditions:\n\n==: Equal to\n!=: Not equal to\n&lt;: Less than\n&gt;: Greater than\n&lt;=: Less than or equal to\n&gt;=: Greater than or equal to\n\n\nage = 45\n\nprint(age == 45)\n\nTrue\n\n\n\nage = 45\nprint(age &gt; 50)\n\nFalse\n\n\n\nage = 45\nprint(age &gt; 50)\n\nFalse\n\n\n\nage = 45\n\nif age &gt; 34:\n    print(\"This person is an adult\")\nelse: \n        print(\"You are young\")\n\nThis person is an adult\n\n\n\nWhat type?\nYou can ask python to tell you the type of the data structure by using type() function:\n\nriver_length_km = 531\nprint(type(river_length_km))\n\n&lt;class 'int'&gt;\n\n\nThe river_lenght_km variable is an integer\n\nriver_name = \"Tugela\"\n\nprint(type(river_name))\n\n&lt;class 'str'&gt;\n\n\n\nis_female = False\n\nprint(type(is_female))\n\n&lt;class 'bool'&gt;\n\n\nIn this section, you have learnt basic data types, functions and operators. Next, we learn different type of data structures."
  },
  {
    "objectID": "my-profile.html",
    "href": "my-profile.html",
    "title": "About Me",
    "section": "",
    "text": "I am a social scientist and human geographer, currently completing a PhD thesis on geographies of youth in Durban. I lecture in the School of Education, University of KwaZulu Natal, Pietermaritzburg Campus. My research interests in:\n\nDevelopment (political economy, geographies, Polanyi)\nSocial Data Science\nComputational social science\nNeighbourhood contexts (education outcomes, health, deprivation)\nYouth studies\nSocial theory (Foucault ‚ù§Ô∏è, Agamben, governance, markets)\nPolitical geography and political participation (protest, elections, behaviour)\n\nI use data science tools, computational methods and statistical methods in my research. I enjoy programming in R and Python."
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "For beginners, I recommend that you set up Python in Anacoda. You will also use VScode IDE for interacting with Python. An IDE makes it easier to code interactively. To set up everything (Anaconda, Python and VSCode) that will be required for this course, please visit this resource and got to ‚ÄúPrerequisites‚Äù section.\nAfter installing everything, you should be able to start coding."
  },
  {
    "objectID": "getting-started.html#installing-python",
    "href": "getting-started.html#installing-python",
    "title": "Getting Started",
    "section": "",
    "text": "For beginners, I recommend that you set up Python in Anacoda. You will also use VScode IDE for interacting with Python. An IDE makes it easier to code interactively. To set up everything (Anaconda, Python and VSCode) that will be required for this course, please visit this resource and got to ‚ÄúPrerequisites‚Äù section.\nAfter installing everything, you should be able to start coding."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Data Science: A gentle introduction",
    "section": "",
    "text": "These workshops aim to introduce participants to the foundations of data science using Python programming Language. As you advance in our studies and career, you will learn that the ability to collect, clean, transform, analyse and use data for predictive analytics is one of the most needed skills in the labour market. As we live in the digital age, where big data has become a commodity, learning to handle these data systems will be one of the most important investments in your career.\nIn this course, we will be using Python for programming and data analysis. Python along with R, is flexible when working with data, especially large data. Majority of academics, researchers, and students who analyse quantitative data use programs such as SPSS, STATA and Excel. However, these programs are expensive! Universities spend large sums of money to purchase these licences, which disadvantages students and academics in the developing world. They are also very limited in handling various data formats such as big data, text data, geospatial data, etc. But if you insist on learning them, good for you.\n\nOn the other hand, Python and R are free and come with with ABSOLUTELY NO WARRANTY üòé . They are very flexible and can handle very large data. They are the dominant programming languages used in the labour market around the world. Python and R have thousands of libraries that can handle and analyse any type of data, including basic data cleaning and wrangling, transforming data, regression, visualisation, text analysis and natural language processing, statistical analysis, machine learning, geospatial analysis and visualisation. In academia, researchers are encouraged to make their research outputs Reproducible, that is, researchers must share code, data and analysis when submitting papers to journals. This is called Reproducible Science.\nBoth Python and R are awesome programming languages. In this course we will be working with Python. If you are interested in R, there is another course that I have designed for you, you can access it here"
  },
  {
    "objectID": "index.html#an-invitation-to-python-for-data-science",
    "href": "index.html#an-invitation-to-python-for-data-science",
    "title": "Python for Data Science: A gentle introduction",
    "section": "",
    "text": "These workshops aim to introduce participants to the foundations of data science using Python programming Language. As you advance in our studies and career, you will learn that the ability to collect, clean, transform, analyse and use data for predictive analytics is one of the most needed skills in the labour market. As we live in the digital age, where big data has become a commodity, learning to handle these data systems will be one of the most important investments in your career.\nIn this course, we will be using Python for programming and data analysis. Python along with R, is flexible when working with data, especially large data. Majority of academics, researchers, and students who analyse quantitative data use programs such as SPSS, STATA and Excel. However, these programs are expensive! Universities spend large sums of money to purchase these licences, which disadvantages students and academics in the developing world. They are also very limited in handling various data formats such as big data, text data, geospatial data, etc. But if you insist on learning them, good for you.\n\nOn the other hand, Python and R are free and come with with ABSOLUTELY NO WARRANTY üòé . They are very flexible and can handle very large data. They are the dominant programming languages used in the labour market around the world. Python and R have thousands of libraries that can handle and analyse any type of data, including basic data cleaning and wrangling, transforming data, regression, visualisation, text analysis and natural language processing, statistical analysis, machine learning, geospatial analysis and visualisation. In academia, researchers are encouraged to make their research outputs Reproducible, that is, researchers must share code, data and analysis when submitting papers to journals. This is called Reproducible Science.\nBoth Python and R are awesome programming languages. In this course we will be working with Python. If you are interested in R, there is another course that I have designed for you, you can access it here"
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand Python and its functions\nConduct basic programming using Python\nLearn to wrangle, clean and transform data\nLearn the basics of data visualisation using matplotlib\nLearn how to conduct exploratory data analysis\nLearn to communicate and tell stories using data"
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Materials",
    "text": "Materials\nThere are tons of materials available online; some of the most popular books include:\n\nMcKinney, W. (2022). Python for data analysis, 3rd Edition. O‚ÄôReilly Media\nVanderPlas, J. (2016). Python data science handbook: Essential tools for working with data. O‚ÄôReilly Media"
  },
  {
    "objectID": "index.html#lets-get-started",
    "href": "index.html#lets-get-started",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Let‚Äôs Get Started",
    "text": "Let‚Äôs Get Started"
  },
  {
    "objectID": "weeks/week-1b.html",
    "href": "weeks/week-1b.html",
    "title": "2 Data Structures in Python",
    "section": "",
    "text": "In this chapter we deal with different data structures that can hold data in Python. Specifically, we will focus on the follwoing data structures:\n\nLists\nTuples\nDictionaries\nDataFrames\n\n\nLists\nList is a data structure that store a collection of elements/items within it. For example, in previous chapter we created a string variable named country that contained ‚ÄúSouth Africa‚Äù element:\n\ncountry = \"South Africa\"\n\nprint(country)\n\nSouth Africa\n\n\nWhat if we wanted to create another country variable, named country_2 with ‚ÄúZimbabwe‚Äù as an element? We can also do this:\n\ncountry_2 = \"Zimbabwe\"\nprint(country_2)\n\nZimbabwe\n\n\nWhat if we want to add country_3, country_4, etc? We can end up having many variables. This where lists come in. Lists are used to hold many items together. you can create lists in Python by using square barackets ([]):\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nWe now have a list of all countries in the Southern African region. There are various functions that can be used to extract, analyse and manipulate elements in a list. For example, you may be interested on how many elements are in a lists; in our case, how many countries are in the southern_african_countries list. You can use the len() function:\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(len(southern_african_countries))\n\n10\n\n\nThe list has 10 elements/items.\n\nSubset a list\nYou can extract the list item by using the [] and the index position of the item. Note that Python index start at 0, meaning the first element will be in the position 0. This is important especially when coming from R background. Let extract the first element:\n\nprint(southern_african_countries[0])\n\nAngola\n\n\nThe first element is Angola.\nYou can use can access the last element by:\n\nprint(southern_african_countries[-1])\n\nZimbabwe\n\n\nYou can access more than 1 items; for example, extract the first, second and third items in the list by slicing:\n\nprint(southern_african_countries[0:3])\n\n['Angola', 'Botswana', 'Lesotho']\n\n\nNotice that we have included the index 3, which is the 4th item, although the element itself is not printed. When slicing a list, the last index mentioned is not included. This is very importnt to note. There are other slicing options:\n\nprint(southern_african_countries[:3])\n\n['Angola', 'Botswana', 'Lesotho']\n\n\n\n\nManipulate a list\nList elements can be changed. For example, in 2018 Zwaziland changed their name to ‚ÄúeSwatini‚Äù. We can change this in a list. First re-create the list:\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nThen change the list element:\n\nsouthern_african_countries[7] = \"eSwatini\"\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe']\n\n\nWe have changed the list element from ‚ÄúSwaziland‚Äù to ‚ÄúEswatini‚Äù.\nYou can also add new elements in a list. Suppose a geographer told us that our list of Southern African countries missed 3 countries: Democratic Republic of the Congo, Mauritius, Madagascar and Seychelles. In Python, we can update our list and assign it to anew variable called southern_africa_updated. First find the length of the original southern_african_countries:\n\nlen(southern_african_countries)\n\n10\n\n\nAdd new items:\n\nsouthern_africa_updated = southern_african_countries + [\"Democratic Republic of the Congo\", \"Mauritius\", \"Madagascar\", \"Seychelles\"]\n\nprint(southern_africa_updated)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe', 'Democratic Republic of the Congo', 'Mauritius', 'Madagascar', 'Seychelles']\n\n\nFind the lenght of the updated variable:\n\nlen(southern_africa_updated)\n\n14\n\n\nThe updated variable has lenght of 14. This means we have added 4 items.\nYou can remove an element from the list by using del() function:\n\ndel southern_africa_updated[0]\n\nprint(southern_africa_updated)\n\n['Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe', 'Democratic Republic of the Congo', 'Mauritius', 'Madagascar', 'Seychelles']\n\n\nWe have removed the element at the index 0, which is Botswana.\n\n\nManipulating list with numeric data\nIn above examples we have worked with list that contain string data types: all out elements were string (country names). Suppose we have the life expectancy of those countries. Life expectancy is the average number of years is expected to live:\nLet us create a numeric list, that we name life_expectancy, that has the average life expectancy of the countries of Southern Africa:\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\nprint(life_expectancy)\n\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nWe can find the minimum life expactancy:\n\nprint(min(life_expectancy))\n\n53.1\n\n\nPrint the maximum life expectancy:\n\nprint(max(life_expectancy))\n\n62.9\n\n\nNot that a list can hold elements of of different data types: string, float, integer, boolean, etc.\nperson_1 = [‚ÄúName‚Äù, ‚ÄúAubrey‚Äù, ‚ÄúAge‚Äù, 32, ‚ÄúHeight‚Äù, 1.8, ‚ÄúIs male?‚Äù, True] print(person_1) ```\n\n\nNumPy Arrays\nA NumPy array is a data structure that can hold numeic elements. It is short for Numeric Python. It is an important data structure if you want to manipulate numeric data. First, you will need to install the numpy package if not already installed:\n\npip install numpy\n\nThen load the library as:\n\nimport numpy as np\n\nSuppose we have the lenght in kilometers of major South Africa rivers stored as a list and assigned it to river_lenght_km variable:\n\nriver_lenght_km = [2200, 1800, 1210, 502, 560, 645, 520, 480]\nprint(river_lenght_km)\n\n[2200, 1800, 1210, 502, 560, 645, 520, 480]\n\n\nWe need to convert this lift into an numpy array:\n\nriver_lenght_km = np.array(river_lenght_km)\n\nprint(type(river_lenght_km))\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\nSummary statistics and mathematical operations\nThere many functions within the numpy library. We can calculate summary statistics:\nGet the mean/average:\n\nprint(np.mean(river_lenght_km))\n\n989.625\n\n\nGet the median:\n\nprint(np.median(river_lenght_km))\n\n602.5\n\n\nGet the standard deviation:\n\nprint(np.std(river_lenght_km))\n\n631.6316049526021\n\n\nThere are other functions you can use.\nWhat are the rivers that have lenght of greater than 1000 kilometers? Find these and assign the result to a variable named longest_rivers\n\nlongest_rivers = river_lenght_km[river_lenght_km &gt; 1000]\nprint(longest_rivers)\n\n[2200 1800 1210]\n\n\nThe river_lenght_km array is in kilometers. What if we want to convert to meters? Since 1 km = 1000 meters, you can convert kilometer to meter by multplying by 1000 since. Let‚Äôs do this and assign result to a new variable named river_lenght_meters\n\nriver_lenght_meters = river_lenght_km * 1000\n\nprint(river_lenght_meters)\n\n[2200000 1800000 1210000  502000  560000  645000  520000  480000]\n\n\nJust like lists, you can subsets numpy arrays using index positions of the element. To acces the second element of river_lenght_km:\n\nprint(river_lenght_km[1])\n\n1800\n\n\nYou can sort elements into ascending or descending order:\n\nnp.sort(river_lenght_km)\n\narray([ 480,  502,  520,  560,  645, 1210, 1800, 2200])\n\n\nSort into descending\n\nnp.sort(river_lenght_km)[::-1]\n\narray([2200, 1800, 1210,  645,  560,  520,  502,  480])\n\n\nNote that NumPy arrays can also be 2 dimensional; 2D arrays is a matrix like data with rows and columns:\n\ntwo_d_array = np.array([[1, 2, 3],\n                   [4, 5, 6],\n                   [7, 8, 9]])\n\nprint(two_d_array)\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n\n\n\n\n\n\nDictionaries\nRemeember we created two lists previously, southern_african_countries and life_expectancy.\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\nprint(life_expectancy)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nWe can find the corresponding life expectancy of, for example, ‚ÄúBotswana‚Äù. First find the index position of Botswana:\n\nbotswana_index = southern_african_countries.index(\"Botswana\")\n\nprint(botswana_index)\n\n1\n\n\nThe index of Botswana is 1. We can access the corresposing life expectancy:\n\nlife_expectancy[botswana_index]\n\n61.1\n\n\nThe life expectancy of Botswana. But this is not efficient if we have large data. This where dictionaries come in:\n\nsouthern_africa = {\"Angola\":61.6, \n                   \"Botswana\":61.1,\n                   \"Lesotho\":57.1,\n                   \"Malawi\":53.1,\n                   \"Mozambique\":62.9,\n                   \"Namibia\":59.3}\n\nprint(southern_africa)\n\n{'Angola': 61.6, 'Botswana': 61.1, 'Lesotho': 57.1, 'Malawi': 53.1, 'Mozambique': 62.9, 'Namibia': 59.3}\n\n\nWe have created a dictionary named southern_africa. A dictionary has keys and values and this is always in pairs. For example, we have Angola as a key with its corresponding value 61.6.\nYou can find values of each keys:\n\nprint(southern_africa[\"Malawi\"])\n\n53.1\n\n\nOf Namibia:\n\nprint(southern_africa[\"Namibia\"])\n\n59.3\n\n\nYou can find keys of all keys:\n\nprint(southern_africa.keys())\n\ndict_keys(['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia'])\n\n\nIf you look at the southern_africa dictionary, we did not include all other countries in the region. We may need to add, let say, Zimbabwe:\n\nsouthern_africa[\"Zimbabwe\"] = 59.3\n\nprint(southern_africa)\n\n{'Angola': 61.6, 'Botswana': 61.1, 'Lesotho': 57.1, 'Malawi': 53.1, 'Mozambique': 62.9, 'Namibia': 59.3, 'Zimbabwe': 59.3}\n\n\nYou can see that the dictionary has been updated to include Zimbwabwe.\nSuppose demographer pouint out that the values of Botswana is outdated; that the life expectancy of the country has increased from 61.1 to 63! We can update this information\n\nsouthern_africa[\"Botswana\"] = 63\n\nprint(southern_africa[\"Botswana\"])\n\n63\n\n\nThe value of Botswana has been changed.\nWhat if we want to add new information in the dictionary? For example, we may want to add the capital cities of the countries in the southern_africa dicitionary:\n\nsouthern_africa_2 = {\"Angola\": {\"life_expectancy\": 61.6, \"capital\":\"Luanda\"},\n                     \"Botswana\": {\"life_expectancy\": 61.1, \"capital\":\"Gaborone\"},\n                     \"Lesotho\": {\"life_expectancy\": 57.1, \"capital\":\"Maseru\"},\n                     \"Malawi\": {\"life_expectancy\": 53.1, \"capital\":\"Lilongwe\"},\n                     \"Mozambique\": {\"life_expectancy\": 62.9, \"capital\":\"Maputo\"},\n                     \"Namibia\": {\"life_expectancy\": 59.3, \"capital\":\"Windhoek\"}}\n\nprint(southern_africa_2)\n\n{'Angola': {'life_expectancy': 61.6, 'capital': 'Luanda'}, 'Botswana': {'life_expectancy': 61.1, 'capital': 'Gaborone'}, 'Lesotho': {'life_expectancy': 57.1, 'capital': 'Maseru'}, 'Malawi': {'life_expectancy': 53.1, 'capital': 'Lilongwe'}, 'Mozambique': {'life_expectancy': 62.9, 'capital': 'Maputo'}, 'Namibia': {'life_expectancy': 59.3, 'capital': 'Windhoek'}}\n\n\nAs you can see in the results, the dictionary has been updated.\n\nDataFrames\nThe previous data structures we have discussed (lists, np.arrays, dictionaries) can handly limited amount of data. In the real world, most data comes big, in a tabular format: with columns and rows. In Python, we use we use the pandas package to handle data in a tabular format. You need to install it first:\n\npip install pandas\n\nThen import pandas:\n\nimport pandas as pd\n\nLet return to the previous lists that we have created: list of Southern African countries and corresponding life expectancy:\n\ncountry = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(country)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nCreate life_expectancy list:\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\nprint(life_expectancy)\n\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nLet‚Äôs add one more list of, for example, population of each country:\n\npopulation = [500, 600, 1000, 150, 490, 740, 300, 781, 610, 504]\n\nprint(population)\n\n[500, 600, 1000, 150, 490, 740, 300, 781, 610, 504]\n\n\nFrom these three lists, we can create a DataFrame using pandas:\n\nsouthern_africa_df = pd.DataFrame({\"country_name\":country, \"life_expect\": life_expectancy, \"pop\":population})\n\nprint(southern_africa_df)\n\n   country_name  life_expect   pop\n0        Angola         61.6   500\n1      Botswana         61.1   600\n2       Lesotho         57.1  1000\n3        Malawi         53.1   150\n4    Mozambique         62.9   490\n5       Namibia         59.3   740\n6  South Africa         59.3   300\n7     Swaziland         62.3   781\n8        Zambia         61.2   610\n9      Zimbabwe         59.3   504\n\n\nWe have a DataFrame with three columns: country_name, life_expect, and pop and 10 rows (observations), where each row represent country. You can use the .head() function to view the first observations\n\nprint(southern_africa_df.head())\n\n  country_name  life_expect   pop\n0       Angola         61.6   500\n1     Botswana         61.1   600\n2      Lesotho         57.1  1000\n3       Malawi         53.1   150\n4   Mozambique         62.9   490\n\n\nYou can check how many columns and rows in the DataFrame by using .info() function:\n\nprint(southern_africa_df.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 10 entries, 0 to 9\nData columns (total 3 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   country_name  10 non-null     object \n 1   life_expect   10 non-null     float64\n 2   pop           10 non-null     int64  \ndtypes: float64(1), int64(1), object(1)\nmemory usage: 368.0+ bytes\nNone\n\n\nYou can get more information of your DataFrame by using .describe() function, it will return the summary statistics of all numeric columns:\n\nprint(southern_africa_df.describe())\n\n       life_expect          pop\ncount    10.000000    10.000000\nmean     59.720000   567.500000\nstd       2.898582   241.687241\nmin      53.100000   150.000000\n25%      59.300000   492.500000\n50%      60.200000   552.000000\n75%      61.500000   707.500000\nmax      62.900000  1000.000000\n\n\nYou can subset both rows and columns, to return only those you are interested in. Let‚Äôs say you want to select only country_name and pop columns, you can do this by wrapping the DataFrame within double square brackets ([[]]) and specify those coulumns:\n\nprint(southern_africa_df[[\"country_name\", \"pop\"]])\n\n   country_name   pop\n0        Angola   500\n1      Botswana   600\n2       Lesotho  1000\n3        Malawi   150\n4    Mozambique   490\n5       Namibia   740\n6  South Africa   300\n7     Swaziland   781\n8        Zambia   610\n9      Zimbabwe   504\n\n\nYou can also select rows. For example, subset observations from Angola and save as a new DataFrame named angola:\n\nangola = southern_africa_df[southern_africa_df[\"country_name\"] == \"Angola\"]\n\nprint(angola)\n\n  country_name  life_expect  pop\n0       Angola         61.6  500\n\n\nSelect observations from Angola and Zimbabwe:\n\nangola_zim = southern_africa_df[southern_africa_df[\"country_name\"].isin([\"Angola\", \"Zimbabwe\"])]\nprint(angola_zim)\n\n  country_name  life_expect  pop\n0       Angola         61.6  500\n9     Zimbabwe         59.3  504\n\n\nSubset observations where life expectancy is below 60:\n\nlow_life_expect = southern_africa_df[southern_africa_df[\"life_expect\"] &lt; 60]\n\nprint(low_life_expect)\n\n   country_name  life_expect   pop\n2       Lesotho         57.1  1000\n3        Malawi         53.1   150\n5       Namibia         59.3   740\n6  South Africa         59.3   300\n9      Zimbabwe         59.3   504\n\n\nThere are many other ways in which you can manipulate, transform and analyse DataFrame, and pandas provide many methods to handle DataFrames. We will dive deepr into DataFrames and Pandas in Week 3\nIn this chapter we have discussed different data structures that can hold data:\n\nLists\nNumpy Arrays\nDictionaries\nDataFrames\n\nIn the next chapter, we explore various ways in which we can visualise data."
  },
  {
    "objectID": "weeks/week-3.html",
    "href": "weeks/week-3.html",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Understand DataFrames\nManipulate, transform and analyse DataFrames\n\n\n\n\nDataframes, as we saw the previous section, is a tabular data format, with columns and rows. Columns are variable names and rows are individual observations. Just like other data structures dicussed in previous chapters, a DataFrame handles different data types: - int64: whole numbers (e.g age = 30)\n\nfloat64; numbers with decimals (e.g.¬†height = 1.9, temperature = 33.0)\ndatetime64: date and time\ncategory: catogories or factors (e.g.¬†gender = male, female; race = black, white, ‚Ä¶)\nbool: True or False\nobject: string and mixed data types\n\nAccording to Hadley Wickman, a DataFrame should be in a tidy format:\n\n\nEach variable is a column; each column is a variable.\nEach observation is row; each row is an observation.\nEach value is a cell; each cell is a single value.\n\n\nThe pandas package provide a toolbox of working analysing, querying and transforming DataFrames. We will continue working with the `gapminder dataset. First load pandas and read the data, saving it as ‚Äúgapminder‚Äù:\n\nimport pandas as pd\n\ngapminder = pd.read_csv(\"https://raw.githubusercontent.com/aubreympungose/data-science-course/main/weeks/data/gapminder.csv\")\n\nLet‚Äôs examine the data by looking at few observations:\n\ngapminder.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nYou can check how many variables are in the data and what type of data:\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nYou can see that gapminder has 6 columns and 1704 rows. The columns in the dataset are:\n\ncountry: Simply the country\ncontinent: Continent\nyear: The year data was collected\nlifeExp: Life expectancy of a country in year\npop: Population of the country in a year\ngdpPercap: Gross Domestic Product of a country in a year\n\nYou can also print the columns in the dataset by using .columns attribute.\n\ngapminder.columns\n\nIndex(['country', 'continent', 'year', 'lifeExp', 'pop', 'gdpPercap'], dtype='object')\n\n\nYou can get the number of rows by using .index attribute:\n\ngapminder.index\n\nRangeIndex(start=0, stop=1704, step=1)\n\n\n\n\n\n\n\nWe may be interested in some of the columns in the gampminder dataframe, let say, for example, ‚Äúcountry‚Äù only. You can select a specific column by taking the name of the DataFrame, followed by square brackets ([]) and passing the name of the ‚Äúcolumn‚Äù inside square brackets:\n\ngapminder[\"country\"]\n\n0       Afghanistan\n1       Afghanistan\n2       Afghanistan\n3       Afghanistan\n4       Afghanistan\n           ...     \n1699       Zimbabwe\n1700       Zimbabwe\n1701       Zimbabwe\n1702       Zimbabwe\n1703       Zimbabwe\nName: country, Length: 1704, dtype: object\n\n\nTo Access multiple, columns you follow the same method as above, except that you wrap column names list ([]), so you end up with double sqaure brackets. Let‚Äôs say we want to select ‚Äúcountry‚Äù, ‚Äúpop‚Äù, and ‚Äúyear‚Äù columns:\n\ngapminder[[\"country\", \"pop\", \"year\"]]\n\n\n\n\n\n\n\n\ncountry\npop\nyear\n\n\n\n\n0\nAfghanistan\n8425333\n1952\n\n\n1\nAfghanistan\n9240934\n1957\n\n\n2\nAfghanistan\n10267083\n1962\n\n\n3\nAfghanistan\n11537966\n1967\n\n\n4\nAfghanistan\n13079460\n1972\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\n9216418\n1987\n\n\n1700\nZimbabwe\n10704340\n1992\n\n\n1701\nZimbabwe\n11404948\n1997\n\n\n1702\nZimbabwe\n11926563\n2002\n\n\n1703\nZimbabwe\n12311143\n2007\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\nYou can alse access columns by their index using .iloc() function. Remember that an index in Python starts at 0, for example, to access the first column\n\ngapminder.iloc[:, 0]\n\n0       Afghanistan\n1       Afghanistan\n2       Afghanistan\n3       Afghanistan\n4       Afghanistan\n           ...     \n1699       Zimbabwe\n1700       Zimbabwe\n1701       Zimbabwe\n1702       Zimbabwe\n1703       Zimbabwe\nName: country, Length: 1704, dtype: object\n\n\nIn the above code, the colon (:) specify that we want to retun all rows; you will more abouth this when selecting by both columns and rows.\nTo access multiple columns, you pass a list of indexes of columns. For example, select the 1st, 3rd and 5th columns:\n\ngapminder.iloc[:, [0, 2, 4]]\n\n\n\n\n\n\n\n\ncountry\nyear\npop\n\n\n\n\n0\nAfghanistan\n1952\n8425333\n\n\n1\nAfghanistan\n1957\n9240934\n\n\n2\nAfghanistan\n1962\n10267083\n\n\n3\nAfghanistan\n1967\n11537966\n\n\n4\nAfghanistan\n1972\n13079460\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\n1987\n9216418\n\n\n1700\nZimbabwe\n1992\n10704340\n\n\n1701\nZimbabwe\n1997\n11404948\n\n\n1702\nZimbabwe\n2002\n11926563\n\n\n1703\nZimbabwe\n2007\n12311143\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\nSuppose you want access a range of of columns, for example, from the 1st to the 3rd column:\n\ngapminder.iloc[:, 0:3]\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n\n\n1\nAfghanistan\nAsia\n1957\n\n\n2\nAfghanistan\nAsia\n1962\n\n\n3\nAfghanistan\nAsia\n1967\n\n\n4\nAfghanistan\nAsia\n1972\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\nAfrica\n1987\n\n\n1700\nZimbabwe\nAfrica\n1992\n\n\n1701\nZimbabwe\nAfrica\n1997\n\n\n1702\nZimbabwe\nAfrica\n2002\n\n\n1703\nZimbabwe\nAfrica\n2007\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\n\n\n\nYou may need to change column names. For example, in the gapminder dataset, we may change the ‚Äúpop‚Äù column to population. You will use the .rename() function, pass the column argument, and specify column names within the dictionary ({\"old_name\":\"new_name\"}). We will assign the results to the new DataFrame named gapminder_new:\n\ngapminder_new = gapminder.rename(columns = {\"pop\":\"population\"})\n\ngapminder_new.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npopulation\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nThe ‚Äúpop‚Äù column has been changed to ‚Äúpopulation‚Äù.\nYou can also rename multiple columns; in this case, rename ‚ÄúlifeExp‚Äù and ‚ÄúgdpPercap‚Äù:\n\ngapminder_new = gapminder.rename(columns = {\"lifeExp\":\"life_expectancy\", \"gdpPercap\":\"gdp_pc\"})\n\ngapminder_new.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlife_expectancy\npop\ngdp_pc\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106"
  },
  {
    "objectID": "weeks/week-3.html#learning-objectives",
    "href": "weeks/week-3.html#learning-objectives",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Understand DataFrames\nManipulate, transform and analyse DataFrames"
  },
  {
    "objectID": "weeks/week-3.html#introduction",
    "href": "weeks/week-3.html#introduction",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Dataframes, as we saw the previous section, is a tabular data format, with columns and rows. Columns are variable names and rows are individual observations. Just like other data structures dicussed in previous chapters, a DataFrame handles different data types: - int64: whole numbers (e.g age = 30)\n\nfloat64; numbers with decimals (e.g.¬†height = 1.9, temperature = 33.0)\ndatetime64: date and time\ncategory: catogories or factors (e.g.¬†gender = male, female; race = black, white, ‚Ä¶)\nbool: True or False\nobject: string and mixed data types\n\nAccording to Hadley Wickman, a DataFrame should be in a tidy format:\n\n\nEach variable is a column; each column is a variable.\nEach observation is row; each row is an observation.\nEach value is a cell; each cell is a single value.\n\n\nThe pandas package provide a toolbox of working analysing, querying and transforming DataFrames. We will continue working with the `gapminder dataset. First load pandas and read the data, saving it as ‚Äúgapminder‚Äù:\n\nimport pandas as pd\n\ngapminder = pd.read_csv(\"https://raw.githubusercontent.com/aubreympungose/data-science-course/main/weeks/data/gapminder.csv\")\n\nLet‚Äôs examine the data by looking at few observations:\n\ngapminder.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nYou can check how many variables are in the data and what type of data:\n\ngapminder.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1704 entries, 0 to 1703\nData columns (total 6 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   country    1704 non-null   object \n 1   continent  1704 non-null   object \n 2   year       1704 non-null   int64  \n 3   lifeExp    1704 non-null   float64\n 4   pop        1704 non-null   int64  \n 5   gdpPercap  1704 non-null   float64\ndtypes: float64(2), int64(2), object(2)\nmemory usage: 80.0+ KB\n\n\nYou can see that gapminder has 6 columns and 1704 rows. The columns in the dataset are:\n\ncountry: Simply the country\ncontinent: Continent\nyear: The year data was collected\nlifeExp: Life expectancy of a country in year\npop: Population of the country in a year\ngdpPercap: Gross Domestic Product of a country in a year\n\nYou can also print the columns in the dataset by using .columns attribute.\n\ngapminder.columns\n\nIndex(['country', 'continent', 'year', 'lifeExp', 'pop', 'gdpPercap'], dtype='object')\n\n\nYou can get the number of rows by using .index attribute:\n\ngapminder.index\n\nRangeIndex(start=0, stop=1704, step=1)"
  },
  {
    "objectID": "weeks/week-3.html#manipulating-columns",
    "href": "weeks/week-3.html#manipulating-columns",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "We may be interested in some of the columns in the gampminder dataframe, let say, for example, ‚Äúcountry‚Äù only. You can select a specific column by taking the name of the DataFrame, followed by square brackets ([]) and passing the name of the ‚Äúcolumn‚Äù inside square brackets:\n\ngapminder[\"country\"]\n\n0       Afghanistan\n1       Afghanistan\n2       Afghanistan\n3       Afghanistan\n4       Afghanistan\n           ...     \n1699       Zimbabwe\n1700       Zimbabwe\n1701       Zimbabwe\n1702       Zimbabwe\n1703       Zimbabwe\nName: country, Length: 1704, dtype: object\n\n\nTo Access multiple, columns you follow the same method as above, except that you wrap column names list ([]), so you end up with double sqaure brackets. Let‚Äôs say we want to select ‚Äúcountry‚Äù, ‚Äúpop‚Äù, and ‚Äúyear‚Äù columns:\n\ngapminder[[\"country\", \"pop\", \"year\"]]\n\n\n\n\n\n\n\n\ncountry\npop\nyear\n\n\n\n\n0\nAfghanistan\n8425333\n1952\n\n\n1\nAfghanistan\n9240934\n1957\n\n\n2\nAfghanistan\n10267083\n1962\n\n\n3\nAfghanistan\n11537966\n1967\n\n\n4\nAfghanistan\n13079460\n1972\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\n9216418\n1987\n\n\n1700\nZimbabwe\n10704340\n1992\n\n\n1701\nZimbabwe\n11404948\n1997\n\n\n1702\nZimbabwe\n11926563\n2002\n\n\n1703\nZimbabwe\n12311143\n2007\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\nYou can alse access columns by their index using .iloc() function. Remember that an index in Python starts at 0, for example, to access the first column\n\ngapminder.iloc[:, 0]\n\n0       Afghanistan\n1       Afghanistan\n2       Afghanistan\n3       Afghanistan\n4       Afghanistan\n           ...     \n1699       Zimbabwe\n1700       Zimbabwe\n1701       Zimbabwe\n1702       Zimbabwe\n1703       Zimbabwe\nName: country, Length: 1704, dtype: object\n\n\nIn the above code, the colon (:) specify that we want to retun all rows; you will more abouth this when selecting by both columns and rows.\nTo access multiple columns, you pass a list of indexes of columns. For example, select the 1st, 3rd and 5th columns:\n\ngapminder.iloc[:, [0, 2, 4]]\n\n\n\n\n\n\n\n\ncountry\nyear\npop\n\n\n\n\n0\nAfghanistan\n1952\n8425333\n\n\n1\nAfghanistan\n1957\n9240934\n\n\n2\nAfghanistan\n1962\n10267083\n\n\n3\nAfghanistan\n1967\n11537966\n\n\n4\nAfghanistan\n1972\n13079460\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\n1987\n9216418\n\n\n1700\nZimbabwe\n1992\n10704340\n\n\n1701\nZimbabwe\n1997\n11404948\n\n\n1702\nZimbabwe\n2002\n11926563\n\n\n1703\nZimbabwe\n2007\n12311143\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\nSuppose you want access a range of of columns, for example, from the 1st to the 3rd column:\n\ngapminder.iloc[:, 0:3]\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n\n\n1\nAfghanistan\nAsia\n1957\n\n\n2\nAfghanistan\nAsia\n1962\n\n\n3\nAfghanistan\nAsia\n1967\n\n\n4\nAfghanistan\nAsia\n1972\n\n\n...\n...\n...\n...\n\n\n1699\nZimbabwe\nAfrica\n1987\n\n\n1700\nZimbabwe\nAfrica\n1992\n\n\n1701\nZimbabwe\nAfrica\n1997\n\n\n1702\nZimbabwe\nAfrica\n2002\n\n\n1703\nZimbabwe\nAfrica\n2007\n\n\n\n\n1704 rows √ó 3 columns\n\n\n\n\n\n\nYou may need to change column names. For example, in the gapminder dataset, we may change the ‚Äúpop‚Äù column to population. You will use the .rename() function, pass the column argument, and specify column names within the dictionary ({\"old_name\":\"new_name\"}). We will assign the results to the new DataFrame named gapminder_new:\n\ngapminder_new = gapminder.rename(columns = {\"pop\":\"population\"})\n\ngapminder_new.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npopulation\ngdpPercap\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106\n\n\n\n\n\n\n\nThe ‚Äúpop‚Äù column has been changed to ‚Äúpopulation‚Äù.\nYou can also rename multiple columns; in this case, rename ‚ÄúlifeExp‚Äù and ‚ÄúgdpPercap‚Äù:\n\ngapminder_new = gapminder.rename(columns = {\"lifeExp\":\"life_expectancy\", \"gdpPercap\":\"gdp_pc\"})\n\ngapminder_new.head()\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlife_expectancy\npop\ngdp_pc\n\n\n\n\n0\nAfghanistan\nAsia\n1952\n28.801\n8425333\n779.445314\n\n\n1\nAfghanistan\nAsia\n1957\n30.332\n9240934\n820.853030\n\n\n2\nAfghanistan\nAsia\n1962\n31.997\n10267083\n853.100710\n\n\n3\nAfghanistan\nAsia\n1967\n34.020\n11537966\n836.197138\n\n\n4\nAfghanistan\nAsia\n1972\n36.088\n13079460\n739.981106"
  },
  {
    "objectID": "weeks/week-5.html",
    "href": "weeks/week-5.html",
    "title": "Importing Data and Reproducible Workflows",
    "section": "",
    "text": "All along we have been working with data stored as packages in R or fake data. But most of the time data is stored locally on our computers either as .csv, Excel, .txt, pdf, etc. There are functions to import these data types, both in Base R and external packages. But first you will need to tell R the location of the data."
  },
  {
    "objectID": "weeks/week-5.html#importing-data",
    "href": "weeks/week-5.html#importing-data",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.1 Importing data",
    "text": "6.1 Importing data\nTo import csv, you can use the read.csv() function. In my case I have dataset saved as ‚Äúepi_data.csv‚Äù in the the folder named ‚Äúdata‚Äù:\n\ndata &lt;- read.csv(\"data/epi_data.csv\")\n\nhead(data)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5\n\n\nLet us say te same data is saved in as aan Excel workbook with an extension .xlsx, we can use reaedxl package:\n\ninstall.packages(\"reaedxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.2.2\n\nexcel_data &lt;- read_excel(\"data/epi_data.xlsx\")\n\nhead(excel_data)\n\n# A tibble: 6 √ó 8\n  country_code country  region population pop_density    GDP epi_score sdg_index\n  &lt;chr&gt;        &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 AFG          Afghani‚Ä¶ Asia       34.7          53.1  60.3       37.7      46.8\n2 ALB          Albania  Easte‚Ä¶      2.88        105.   32.7       65.5      68.9\n3 DZA          Algeria  Mid E‚Ä¶     40.6          17.0 565.        57.2      68.8\n4 AGO          Angola   Sub-S‚Ä¶     28.8          23.1 172.        37.4      50.2\n5 ATG          Antigua‚Ä¶ Carib‚Ä¶      0.101       229.    2.12      59.2   -9999  \n6 ARG          Argenti‚Ä¶ Latin‚Ä¶     43.8          16.0 811.        59.3      72.5\n\n\nThere are other arguments that can be added; for example if you data is on sheet number 2 of Exel workbook, you will add an sheet = 2 argument.\nYou can import data from other statistical software as well:\n\nRead STATA files: STATA data files end with .dta extensions: read_dta() from Haven package can import this data type\nRead SPPS files: SPSS files end with .sav extension: read_sav() function, also from Haven can import it.\n\nR can import other many data types such shapefiles, images, PDFs and data from the web."
  },
  {
    "objectID": "weeks/week-5.html#importing-multiple-files",
    "href": "weeks/week-5.html#importing-multiple-files",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.2 Importing Multiple files",
    "text": "6.2 Importing Multiple files\nSometimes there are many files and it would be time consuming to load each file. I will show you the following with instructions\n\n## First list the path where files are stored\n\npath &lt;- list.files(\"data\", pattern = \".csv$\", full.names = TRUE) \n\n## Read all the files by using lapply function\ndata_files &lt;- lapply(path, read.csv)\n\nnow you have a list with 2 elements. You can extract each element:\n\nfirst_df &lt;- data_files[[1]]\n\nhead(first_df)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5\n\n\n\nsecond_df &lt;- data_files[[2]]\n\nhead(second_df)\n\n      country continent year lifeExp      pop gdpPercap\n1 Afghanistan      Asia 1952  28.801  8425333  779.4453\n2 Afghanistan      Asia 1957  30.332  9240934  820.8530\n3 Afghanistan      Asia 1962  31.997 10267083  853.1007\n4 Afghanistan      Asia 1967  34.020 11537966  836.1971\n5 Afghanistan      Asia 1972  36.088 13079460  739.9811\n6 Afghanistan      Asia 1977  38.438 14880372  786.1134"
  },
  {
    "objectID": "weeks/week-5.html#exporting-data",
    "href": "weeks/week-5.html#exporting-data",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.3 Exporting data",
    "text": "6.3 Exporting data\nAfter you have cleaned and prepared your data for analysis, you may want to save cleaned data.\n\ngapminder &lt;- gapminder::gapminder\n\ngapminder_2007 &lt;- gapminder |&gt; \n  dplyr::filter(year == 2007)\n\nwrite.csv(gapminder_2007, \"data/gapminder_cleaned.csv\")\n\nNot that your my path ‚Äúdata/gapminder_cleaned.csv‚Äù will be different yours.\n##6.4 Setting working directories\nWhen working on a project, it may be important to set a working directory, where all you files are stores: data, code, reports, etc. You can use setwd() function. Let‚Äôs say we have a folder with all the files:\n\n\nmy_folder\n\ndata\ncode\nreport\n\n\n\nYou will need to set a working directory as:\n\nsetwd(\"C:/Users/mpungosea/my_folder\")\n\nTo navigate to a specific file, you will have to use relative paths. You starting path would be ‚Äúmy_folder‚Äù. If you want to load data, you would have to navigate to ‚Äúdata‚Äù directory:\n\ndata &lt;- read.csv(\"data/epi_data.csv\")\n\nhead(data)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5"
  },
  {
    "objectID": "weeks/week-5.html#managing-reproducible-workflows",
    "href": "weeks/week-5.html#managing-reproducible-workflows",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.5 Managing reproducible workflows",
    "text": "6.5 Managing reproducible workflows\nThe problem with the above approach, of setting working directories, is that your directories are local to your computer. We share code with other people: reviewers, team members, etc. We also collaborate with one another. Now imagine that I have ‚ÄúC:/Users/mpungosea/my_folder‚Äù as my working directory. Will this work on your computer? NO! In Other instances, you may move files; if you run the code and set the director, R will return an error. This means that your workflows are not reproducible and it is not an efficient way of working.\nEnter RStudio Projects. In Projects, we want to keep all the files that were working with and making it easier to navigate directories and share your work. To start a new project, follow these steps:\n\n\nInside the project, you can add the follwoing directories/folders:\n\ndata: to save all your data files: raw data, cleaned data, analysis data, etc\ncode: save all your scripts: data cleaning, analysis, etc\noutputs: figures, tables, etc\nreports: draft reports final reports, etc\nbibliogaphy: a bibtex file with the list of references.\n\nIn one of my projects, this is how it looks:\n\nEvery time you work on the project, you then open the .Rproj file, it will have all the files associated with the project:"
  }
]