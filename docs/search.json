[
  {
    "objectID": "weeks/week-6.html",
    "href": "weeks/week-6.html",
    "title": "Communicating and Reporting with Quarto",
    "section": "",
    "text": "This week I would like to introduce you to writing reproducible reports using Quarto, a next generation “open-source scientific and technical publishing system”. It is an integrated ecosystem, where you can integrate your code, reports, figures, references, tables etc. in one environment. With Quarto you can write:\n\nBooks (examples include: R for Data Science, Second dition; Python for Data Analysis Hands-On Programming with R)\nReproducible journal papers: (some examples: Elsevier Template, )\nWebsite: This website is written with Quarto, hosted in GitHub all for free\nPresentations: (examples: This presentation)\nDynamic reports\nBlogs: personal, work etc. (examples: )\n\nAnd more! See examples on the Quarto website\nQuarto can render documents in multiple formats, including HTML, PDF, word formats, etc."
  },
  {
    "objectID": "weeks/week-6.html#introduction-to-quarto",
    "href": "weeks/week-6.html#introduction-to-quarto",
    "title": "Communicating and Reporting with Quarto",
    "section": "",
    "text": "This week I would like to introduce you to writing reproducible reports using Quarto, a next generation “open-source scientific and technical publishing system”. It is an integrated ecosystem, where you can integrate your code, reports, figures, references, tables etc. in one environment. With Quarto you can write:\n\nBooks (examples include: R for Data Science, Second dition; Python for Data Analysis Hands-On Programming with R)\nReproducible journal papers: (some examples: Elsevier Template, )\nWebsite: This website is written with Quarto, hosted in GitHub all for free\nPresentations: (examples: This presentation)\nDynamic reports\nBlogs: personal, work etc. (examples: )\n\nAnd more! See examples on the Quarto website\nQuarto can render documents in multiple formats, including HTML, PDF, word formats, etc."
  },
  {
    "objectID": "weeks/week-6.html#how-does-quarto-work",
    "href": "weeks/week-6.html#how-does-quarto-work",
    "title": "Communicating and Reporting with Quarto",
    "section": "5.2 How does Quarto Work?",
    "text": "5.2 How does Quarto Work?\nFor all my writing, I have shifted from what Kieran Healy calls the “Office Model” to an “Engineering Model”:\n\nOffice solutions tend towards a cluster of tools where something like Microsoft Word is at the center of your work. A Word file or set of files is the most “real” thing in your project. Changes to your work are tracked inside that file or files. Citation and reference managers plug into those files. The outputs of data analyses—tables, figures—get cut and pasted in as well, or are kept alongside them. The master document may be passed around from person to person to be edited and updated.4 The final output is exported from it, perhaps to PDF or to HTML, but maybe most often the final output just is the .docx file, cleaned up and with the track changes feature turned off.\n\n\nIn the Engineering model, meanwhile, plain text files are at the center of your work. The most “real” thing in your project will either be those files or, more likely, the version control repository that stores the project. Changes are tracked outside of files, again using a version control system. Data analysis is managed in code that produces outputs in (ideally) a known and reproducible manner. Citation and reference management will likely also be done in plain text, as with a BibTeX .bib file. Final outputs are assembled from the plain text and turned to .tex, .html, or .pdf using some kind of typesetting or conversion tool. Very often, because of some unavoidable facts about the world, the final output of this kind of solution is also a .docx file.\n\nQuarto then is the part of the “engineering model”. It mainly uses Markdown format for writing. “Markdown is a lightweight markup language that you can use to add formatting elements to plaintext text documents”."
  },
  {
    "objectID": "weeks/week-6.html#lets-practice",
    "href": "weeks/week-6.html#lets-practice",
    "title": "Communicating and Reporting with Quarto",
    "section": "5.3 Let’s Practice",
    "text": "5.3 Let’s Practice\nYou will need the following:\n\nR and RStudio (or any IDE such as VSCode etc)\nQuarto: If you are using RStudio, Quarto is already installed. If you using other IDEs such as VSCode, download and install Quarto from the Quarto website\nZotero: For references bibliography and citations. Download and install Zotero from Zotero website\nBetter BibTeX (BBT): BBT is a Zotero extension that manages things like citation keys. You can download BBT from: https://retorque.re/zotero-better-bibtex/.\n\nAll these tools are open source and available for free!\n5.3.1 Openning Quarto\nFirst create a directory/folder where you will save all the files. For example I will create a folder named “intro_to_quarto” in my documents directory. This is where you will store all your files.\nIn RStudio, go to FILE -&gt; New File -&gt; Quarto Document\nOn the pop-up window, just select “Create Empty Document”. A blank Quarto page will be open:\n\nSave the document to folder that you have created\n5.3.2 YAMl\nThe first part of the page is know as YAML, it contains the information about the document, this include:\n\nQuarto YML Options\n\n\n\n\n\nOption\nDescription\n\n\n\ntitle\ntittle of the document\n\n\nsubtitle\nsubtitle of the document\n\n\nauthor\nAuthor\n\n\ndate\ndate of the document was published\n\n\nformat\noutput of the document: options include html, docx, pdf, etc\n\n\ntoc\ntable of contents\n\n\nnumber-sections\nAutomatically number headings and sections\n\n\nbibliography\na file containing references\n\n\ncsl\nreferencing style\n\n\n\n\n\n\n\nThere are many other options that you can use to customise your document; you can a complete guide here. Let us experiment with few options.\nLook how I have customised my yaml:\n\nExperiment with other options. Please not that this must be should start with — and end with —.\n5.3.3 Writing using Markdown\nHeadings\nYou insert headings by using # at the beginning of a sentence:\n\n\nSource: Quarto\n\nUpdate your document by including headings as follows:\n---\ntitle: \"Introduction to Quarto\"\nsubtitle: \"Writing Reproducible Documents wih Quarto andd RStudio\"\nauthor: \"Aubrey Mpungose\"\ndate: 04 June 2023\ndate-format: \"DD MMMM YYYY\"\nformat:\n  html:\n    toc: true\n---\n\n# Section 1\n\n\n## Section 1.1 \n\n\n### Section 1.1.1 \n\n\n#### Section 1.1.1.1\n\n\n##### Other section\n\n\n###### Other section\nSave and render the document by clicking on the “Render” option as highlighted on the image below\n\nFormating texts\n\n\nQuarto website\n\nUpdate your document as the following and render the document, obviously your name is not Aubrey Mpungose:\n---\ntitle: \"Introduction to Quarto\"\nsubtitle: \"Writing Reproducible Documents wih Quarto andd RStudio\"\nauthor: \"Aubrey Mpungose\"\ndate: 04 June 2019\ndate-format: \"DD MMMM YYYY\"\nformat:\n  html:\n    toc: true\n---\n\n# 1. Italics\n\nMy name is *Aubrey Mpungose*, I love doing *data science*\n\nI can also format text in _italics_\n\n# 2. Bold \n\nThis is how I format text into **BOLD**\n\n\n# 3. Bold and Italics\n\nI can also format text to be ***Bold and Italic***\n\n\n# 4. Example\n\nMy name is *Aubrey Mpungose*, I love doing _data science_. Some people think markdown syntax is difficult,  but it is not: for example, I can make text to be **Bold**. I can also format text format text to be ***bold and italic***\nThe output will be the following:\n\nFigures/Images\nLet’s say you have an image named meerkat.png in your folder, update your document with the following:\n\nInsert a picture from the web\n\n![A meerkat](meerkat.png)\nThis will inclde the meerkat image in the document. Note that inside [] is the caption, in my case, “A meerkat”. You must put parentheses () after with no spaces.\n\n\nA meerkat\n\nThere are other options for figures including width, length, etc. You can find more from Quarto website.\nComputation and code\nYou can include R, Python, Javascript and other programming languages code within quarto document. We will show some examples using R and gapminder data that we have been using. For example, to insert R code, you insert a code chunk begining with {r} and ends with\nTo load the gapminder data and the tidyverse package, insert the following and render the document:\n\nYou can also label code chunks:\n\nThere are many code chunk options that you can include depending on your needs.\nFigures\nYou can insert figures within quarto document:\n\n\n\n\n\n\nInsert tables\nThe gt package has beautiful table formats. install the package first:\n\ninstall.packages(\"gt\")\n\nThen Run the following code:\n\n\n\n\n\n\n\n\ncountry\ncontinent\nyear\nlifeExp\npop\ngdpPercap\n\n\n\nJapan\nAsia\n2007\n82.603\n127467972\n31656.07\n\n\nHong Kong, China\nAsia\n2007\n82.208\n6980412\n39724.98\n\n\nIceland\nEurope\n2007\n81.757\n301931\n36180.79\n\n\nSwitzerland\nEurope\n2007\n81.701\n7554661\n37506.42\n\n\nAustralia\nOceania\n2007\n81.235\n20434176\n34435.37\n\n\nSpain\nEurope\n2007\n80.941\n40448191\n28821.06\n\n\nSweden\nEurope\n2007\n80.884\n9031088\n33859.75\n\n\nIsrael\nAsia\n2007\n80.745\n6426679\n25523.28\n\n\nFrance\nEurope\n2007\n80.657\n61083916\n30470.02\n\n\nCanada\nAmericas\n2007\n80.653\n33390141\n36319.24\n\n\n\n\n\n\nYou can also customise your tables to include title, subtitle and rename column names\n\ngapminder |&gt; \n  filter(year == 2007) |&gt; \n  arrange(desc(lifeExp)) |&gt; \n  head(10) |&gt; \n  gt() |&gt; \n  tab_header(title = md(\"**Highest Life Expectancy**\")) |&gt; \n  cols_label(country = md(\"**Country**\"),\n             continent = md(\"**Continent**\"),\n             year = md(\"**Year**\"),\n             lifeExp = md(\"**Life expectancy**\"),\n             pop = md(\"**Population**\"),\n             gdpPercap = md(\"**GDP per capita**\"))\n\n\n\n\n\n\nHighest Life Expectancy\n    \n\nCountry\n      Continent\n      Year\n      Life expectancy\n      Population\n      GDP per capita\n    \n\n\nJapan\nAsia\n2007\n82.603\n127467972\n31656.07\n\n\nHong Kong, China\nAsia\n2007\n82.208\n6980412\n39724.98\n\n\nIceland\nEurope\n2007\n81.757\n301931\n36180.79\n\n\nSwitzerland\nEurope\n2007\n81.701\n7554661\n37506.42\n\n\nAustralia\nOceania\n2007\n81.235\n20434176\n34435.37\n\n\nSpain\nEurope\n2007\n80.941\n40448191\n28821.06\n\n\nSweden\nEurope\n2007\n80.884\n9031088\n33859.75\n\n\nIsrael\nAsia\n2007\n80.745\n6426679\n25523.28\n\n\nFrance\nEurope\n2007\n80.657\n61083916\n30470.02\n\n\nCanada\nAmericas\n2007\n80.653\n33390141\n36319.24\n\n\n\n\n\n\nNote that we included md(** **) to specify that this is a markdown syntax and we want to make text bold.\nI will explain how include citations and bibliography in class."
  },
  {
    "objectID": "weeks/week-4.html",
    "href": "weeks/week-4.html",
    "title": "5 Data Manipulation Part 2",
    "section": "",
    "text": "Last week we introduced the basics of data manipulation using dplyr. This week I want u to continue to intermediate data manipulation in dplyr."
  },
  {
    "objectID": "weeks/week-4.html#renaming-columns",
    "href": "weeks/week-4.html#renaming-columns",
    "title": "5 Data Manipulation Part 2",
    "section": "5.1 Renaming columns",
    "text": "5.1 Renaming columns\nYou will notice that the column names in the gapminder dataset do not follow tidy principles. Naming things in a tidy we follow these principles:\n\nNo spaces between characters\nall names should be in lower cases\nonly use underscore (_) to separate characters.\n\nThe tidyverse style guide. In our columns, the column names lifeExp are gdpPercap need to be renamed. We will use rename() function within dplyr:\n\n### Load tidyverse\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n### load the data\n\ngapminder &lt;- gapminder::gapminder\n\ngapminder$country &lt;- as.character(gapminder$country)\n\ngapminder$continent &lt;- as.character(gapminder$continent)\n\nthen use rename() to change column names; we will save the new dataframe as gapminder_new\n\ngapminder_new &lt;- gapminder |&gt; \n  rename(life_expectancy = lifeExp,\n         gdp_per_capita = gdpPercap)\n\nhead(gapminder_new)\n\n# A tibble: 6 × 6\n  country     continent  year life_expectancy      pop gdp_per_capita\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;           &lt;dbl&gt;    &lt;int&gt;          &lt;dbl&gt;\n1 Afghanistan Asia       1952            28.8  8425333           779.\n2 Afghanistan Asia       1957            30.3  9240934           821.\n3 Afghanistan Asia       1962            32.0 10267083           853.\n4 Afghanistan Asia       1967            34.0 11537966           836.\n5 Afghanistan Asia       1972            36.1 13079460           740.\n6 Afghanistan Asia       1977            38.4 14880372           786.\n\n\nThe dataframe is updated with changed column names. However, when working with data with many columns, it would be time consuming to change each column. Fortunately, within the package janitor there is function called clean_names that change all the column names into a tidy way. Install the janitor package first:\n\ninstall.packages(\"janitor\")\n\nAfter install it load it: and use the clean_names() function:\n\nlibrary(janitor)\n\n\nAttaching package: 'janitor'\n\n\nThe following objects are masked from 'package:stats':\n\n    chisq.test, fisher.test\n\ngapminder_new &lt;- clean_names(gapminder)\n\nhead(gapminder_new)\n\n# A tibble: 6 × 6\n  country     continent  year life_exp      pop gdp_percap\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;      &lt;dbl&gt;\n1 Afghanistan Asia       1952     28.8  8425333       779.\n2 Afghanistan Asia       1957     30.3  9240934       821.\n3 Afghanistan Asia       1962     32.0 10267083       853.\n4 Afghanistan Asia       1967     34.0 11537966       836.\n5 Afghanistan Asia       1972     36.1 13079460       740.\n6 Afghanistan Asia       1977     38.4 14880372       786.\n\n\nSee that untidy column names were changed automatically."
  },
  {
    "objectID": "weeks/week-4.html#converting-column-data-types",
    "href": "weeks/week-4.html#converting-column-data-types",
    "title": "5 Data Manipulation Part 2",
    "section": "5.2 Converting column data types",
    "text": "5.2 Converting column data types\nRemember we discussed 3 data types:\n\ncharacter\nnumeric\nlogical\n\nIn a dataframe, you can find the data type of the column by using class() function\n\nclass(gapminder$country)\n\n[1] \"character\"\n\nclass(gapminder$gdpPercap)\n\n[1] \"numeric\"\n\n\nYou can also use the str() to find the data types of all columns in the dataframe:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nSometimes you may find that the all values in a column would be saved as character when they are supposed to be numeric. You can change them as using as.numeric() function. Let us simulate some fake data:\n\ngender &lt;- c(\"male\", \"female\", \"female\", \"male\", \"female\")\n\nage &lt;- c(\"18\", \"30\", \"45\", \"21\", \"54\")\n\nexample_df &lt;- data.frame(gender, age)\n\nexample_df\n\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n\n\nIn the example_df dataframe, you can see that the age column has been stored as character, which doesn’t make any sense:\n\nstr(example_df$age)\n\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n\n\nConvert this:\n\nexample_df$age &lt;- as.numeric(example_df$age)\n\nstr(example_df$age)\n\n num [1:5] 18 30 45 21 54\n\n\nIf you want to convert it back to character, you can use as.character() function:\n\nexample_df$age &lt;- as.character(example_df$age)\n\nstr(example_df$age)\n\n chr [1:5] \"18\" \"30\" \"45\" \"21\" \"54\"\n\n\nThe only time this will not work is when you try to convert a character column such as gender into numeric; try it. Experiment with converting various column type with the gapminder dataset.\n5.2.1 Factors\nThere is another data type we have not discussed: factors or what may be called categorical data. Factors are like characters, except that they have integers that correspond to characters. In our example_df dataframe, we may want to make the column gender a factor, where 1 = male, 2 = female.\n\nhead(example_df)\n\n  gender age\n1   male  18\n2 female  30\n3 female  45\n4   male  21\n5 female  54\n\nexample_df$gender &lt;- factor(example_df$gender, levels = c(\"male\", \"female\"))\n\nstr(example_df)\n\n'data.frame':   5 obs. of  2 variables:\n $ gender: Factor w/ 2 levels \"male\",\"female\": 1 2 2 1 2\n $ age   : chr  \"18\" \"30\" \"45\" \"21\" ...\n\n\nThe gender column has been changed to factor, with 2 levels.\nLet us try to change the continent column in the gapminder dataset, we will try the dplyr method:\n\ngapminder &lt;- gapminder |&gt; \n  mutate(continent_factor = factor(continent))\n\nstr(gapminder$continent_factor)\n\n Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n\n\nHere we have used mutate() to create a new column named continent_factor that is a factor. It has 5 levels, you can check this using the levels() function:\n\nlevels(gapminder$continent_factor)\n\n[1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\" \n\n\nCreating new columns instead of changing the existing one is important in some instances, especially when you want to compare the data.\nThe focrcats package within Tidyverse was specifically create for factors, you may want to visit it to learn more about factors."
  },
  {
    "objectID": "weeks/week-4.html#create-a-new-categorical-column-from-a-numeric-column",
    "href": "weeks/week-4.html#create-a-new-categorical-column-from-a-numeric-column",
    "title": "5 Data Manipulation Part 2",
    "section": "5.3 Create a new categorical column from a numeric column",
    "text": "5.3 Create a new categorical column from a numeric column\nIn many cases, we may want to create a new categorical column that takes the conditions from a numeric column. For example, example, in the following ages:\n\n1-12 = child\n13-17 = adolescent\n18-34 = young adults\n35-55 = adults\nOver 55 = older adults\n\nWe can use the case_when() function within mutate() to create this column. Let us generate some fake data;\n\nset.seed(45)\n###simulate a character vector with a length of 50\ngender &lt;- sample(c(\"male\", \"female\"), size = 50, replace = T, prob = c(.45, .55))\n\n\n## simulate a numeric vector, with a length of 50, from ages 1 to 75\nage &lt;- sample(1:75, size = 50)\n\nfake_df &lt;- tibble(gender, age)\n\nhead(fake_df)\n\n# A tibble: 6 × 2\n  gender   age\n  &lt;chr&gt;  &lt;int&gt;\n1 male      18\n2 female    11\n3 female    55\n4 female    62\n5 female    67\n6 female    27\n\n\nThen compute a new column:\n\nfake_df &lt;- fake_df |&gt; \n  mutate(age_group = case_when(\n    age &gt;= 1 & age &lt;=12 ~ \"child\",\n    age &gt;= 13 & age &lt;= 17 ~ \"adolescent\",\n    age &gt;= 18 & age &lt;= 34 ~ \"young adult\",\n    age &gt;= 35 & age &lt;= 55 ~ \"adult\",\n    age &gt; 55 ~ \"older adult\"\n  ))\n\nfake_df\n\n# A tibble: 50 × 3\n   gender   age age_group  \n   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;      \n 1 male      18 young adult\n 2 female    11 child      \n 3 female    55 adult      \n 4 female    62 older adult\n 5 female    67 older adult\n 6 female    27 young adult\n 7 female    41 adult      \n 8 male       6 child      \n 9 female    10 child      \n10 female    51 adult      \n# ℹ 40 more rows\n\n\nPlot the new column:\n\nfake_df |&gt; \n  ggplot(aes(x = age_group)) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\nWe have created a new column called age_group using the age column.\nExperiment with the gapminder data. We may want to group countries according to their life expectancy based on the following rules:\n\nif life expectancy of a country is lower than the world average, we will classify it as ‘low life expectancy’\nif life expectancy of a country is higher than the world average, we will classify it as ‘high life expectancy’\n\nWe will only use observations from the year 2007:\n\ngapminder_2007 &lt;- gapminder |&gt; \n  filter(year == 2007)\n\nCreate a new column:\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(life_expect_category = case_when(\n    lifeExp &lt; mean(lifeExp) ~ 'low life expectancy',\n    lifeExp &gt; mean(lifeExp) ~ 'high life expectancy'\n  ))\n\nWe have created added a new column called life_expect_category; plot this column:\n\ngapminder_2007 |&gt; \n  ggplot(aes(x = life_expect_category)) +\n  geom_bar() +\n  theme_minimal()\n\n\n\n\n5.4 Missing data\nData rarely comes clean, and sometimes data can contain missing value. In R missing values are stored as NA. Once we go to the introduction to statistics section, we will deal with missing values.\n5.5 Reshaping data\nThere are 2 types of dataframes: wide and long formats. I will use examples to illustrate both types.\nSuppose we have data containing GDP increase rate of South Africa from 2010 to 2020 Let us create a long format of this dataframe:\n\nyear &lt;- c(2010:2020)\n  \ngdp_rate &lt;- c(2.8, 3.1, 3.3, 2.2, 1.9, 1.3, 1.5, 0.6, 0.8, 0.2, -7.0)\n\nsa_gdp_long &lt;- data.frame(year, gdp_rate)\n\nsa_gdp_long\n\n   year gdp_rate\n1  2010      2.8\n2  2011      3.1\n3  2012      3.3\n4  2013      2.2\n5  2014      1.9\n6  2015      1.3\n7  2016      1.5\n8  2017      0.6\n9  2018      0.8\n10 2019      0.2\n11 2020     -7.0\n\n\nThe dataframe is in long format: We have one column reprenting all years, and gdp_rate column representing all values of GDP growth rate. What if we want to change to a wide format? We can use pivot_wider() function within tidyr package, also a part of tydiverse:\n\nsa_gdp_wide &lt;- pivot_wider(sa_gdp_long,  names_from = year, values_from = gdp_rate)\n\nsa_gdp_wide\n\n# A tibble: 1 × 11\n  `2010` `2011` `2012` `2013` `2014` `2015` `2016` `2017` `2018` `2019` `2020`\n   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1    2.8    3.1    3.3    2.2    1.9    1.3    1.5    0.6    0.8    0.2     -7\n\n\nYou can see that in a wide format, each year is a column.\n5.5.1 Excercise\nIn the gapminder data do the following:\n\nSelect country, year and life expectancy columns\nfilter rows rows from South Africa, Zimbabwe and Mozambique\nreshape this data to a wide format"
  },
  {
    "objectID": "weeks/week-4.html#joining-data",
    "href": "weeks/week-4.html#joining-data",
    "title": "5 Data Manipulation Part 2",
    "section": "5.6 Joining data",
    "text": "5.6 Joining data\nYou my have 2 dataframes with corresponding ID columns but with other different column names. Create a first dataframe:\n\ncountry_name &lt;- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(187)\npopulation &lt;- sample(5000:15000, 7)\n\npop_df &lt;- data.frame(country_name, population)\n\npop_df\n\n  country_name population\n1 South Africa       7330\n2     Zimbabwe      11323\n3   Mozambique       7419\n4     Botswana       9156\n5     Eswatini      11783\n6      Lesotho      14088\n7      Namibia       8824\n\n\nCreate a second dataframe:\n\ncountry_name &lt;- c(\"South Africa\", \"Zimbabwe\", \"Mozambique\", \"Botswana\", \"Eswatini\", \"Lesotho\", \"Namibia\")\n\nset.seed(50)\navg_age &lt;- sample(23:35, 7)\n\nage_df &lt;- data.frame(country_name, avg_age)\n\nage_df\n\n  country_name avg_age\n1 South Africa      33\n2     Zimbabwe      26\n3   Mozambique      24\n4     Botswana      29\n5     Eswatini      25\n6      Lesotho      30\n7      Namibia      34\n\n\nNow we have 2 data frames: pop_df with a fake data on countries’ population and the age_df with a fake data on countries’ average age. The common name in both dataframes is country_name. We will use merge() function to join 2 dataframes:\n\ncombined_df &lt;- merge(pop_df, age_df, by = \"country_name\")\n\ncombined_df\n\n  country_name population avg_age\n1     Botswana       9156      29\n2     Eswatini      11783      25\n3      Lesotho      14088      30\n4   Mozambique       7419      24\n5      Namibia       8824      34\n6 South Africa       7330      33\n7     Zimbabwe      11323      26\n\n\nBingo!\nThere is more to joining data: merge() is a Base R funcion. There are other options of joining data using dplyr; see this guide"
  },
  {
    "objectID": "weeks/week-2.html#base-r-vs-external-packages",
    "href": "weeks/week-2.html#base-r-vs-external-packages",
    "title": "3 Data Visualisation",
    "section": "Base R vs External Packages",
    "text": "Base R vs External Packages\nUntil now, we have used functions within Base R, which are already installed in R. While Base/bulit-in R functions are important, however, in many cases, we want to use external packages to do any task we want. This also applies in other programming languages like Python. For example, if we want to do spatial and GIS analysis, we can install the sf package; for machine learning, we can use caret and tidymodels packages. There are over 2 000 R packages, contributed by different individuals around the world, and they are stored and curated in the CRAN website. In most of the cases, you will be working with external packages.\nOne of the most popular packages in R is the tidyverse meta-package, which include a collection of packages for working with data; some of packages in the tidyverse are:\n\ndplyr: for data cleaning, wrangling and transformation\nggplot2: for data visualisation\ntidyr: for tidying up data\nreadr: for importing data\npurrr: for advanced functional programming\nstringr: for manipulating string/text data\n\nThere are other packages in the tidyverse. The philosophy of tidyverse is tidy data:\n\n\nEach variable is a column; each column is a variable.\nEach observation is row; each row is an observation.\nEach value is a cell; each cell is a single value. [@r_4_ds]\n\n\n\n\n\nTidy data\n\nTidy data is a principle we are going to stick on through this course:\n\n\nTidy data @wickham_tidyverse_2019\n\nSo all in all, tidyverse make it easier to work with dataframes and most people prefer it than base R functions. We will use an example at the end to understand the differences between Base R and tydiverse. You will need to install the package first. In R you install a package by calling install.package() function:\n\ninstall.packages(\"tidyverse\")\n\nWhenever you need to use an external package and its functions, you first need to load it using library() function. In our case, we want to load the tidyverse package we have just installed:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nYou will load other packages like this."
  },
  {
    "objectID": "weeks/week-2.html#introduction-to-data-visualisation",
    "href": "weeks/week-2.html#introduction-to-data-visualisation",
    "title": "3 Data Visualisation",
    "section": "3.1 Introduction to data visualisation",
    "text": "3.1 Introduction to data visualisation\nData visualisation is an important skill for data scientists. In fact, data manipulation and visualisations go hand in hand. Before any analysis, it is important to visualise data to explore its distribution, relationships, normality, etc.\nIn this section, we will use the ggplot2 package within tidyverse to learn the foundations of data visualisation. The ggplot2 package got it philosophy from the book The Grammar of Graphics, written by Leland Wilkinson. The ggplot2 package was developed by Hadley Wickham, probably one of the most greatest data scientist in this era.\nWe will be working with the gapminder dataset, which is the real world data. You will need to install its first because it comes as a package:\n\ninstall.packages(\"gapminder\")\n\nAfter installing the gapminder data, you will have to load it using library function:\n\nlibrary(gapminder)\n\nRemember that we said everything we create is an object and we need to assign it? Let us assign gapminder that and name simply as gapminder using the &lt;- operator:\n\ngapminder &lt;- gapminder\n\nExplore the data first; how many columns and rows are in gapminder dataframe? We will use str() function:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nWe can see that gapminder has 6 and 1704. The columns in the dataset are:\n\ncountry: Simply the country\ncontinent: Continent\nyear: The year data was collected\nlifeExp: Life expectancy of a country in year\npop: Population of the country in a year\ngdpPercap: Gross Domestic Product of a country in a year\n\nggplot2 has steps/processes you follow to create a plot. Let us illustrate using the gapminder dataset. Load ggplot2 package first:\n\nlibrary(ggplot2)\n\nA plot created in using ggplot2 has the following components/layers, and we will go through them step-by-step:\n\n\nsource"
  },
  {
    "objectID": "weeks/week-2.html#create-a-plot",
    "href": "weeks/week-2.html#create-a-plot",
    "title": "3 Data Visualisation",
    "section": "3.2 Create a plot",
    "text": "3.2 Create a plot\nFrom the ggapminder dataframe, we will create a scatterplot of life expectancy and GDP per capita, and add all the components of ggplot step-by-step.\n3.2.1 Layer 1: data\nWe use the ggplot() function to add data, in this case, gapminder dataframe:\n\nggplot(data = gapminder)\n\n\n\n\n3.2.2 Layer 2: aesthetics\nAesthetics are used to allocate x and y variables, depending on the type of the plot we want to create, in this case, x variable is gdpPercap and y variable is lifeExp:\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp))\n\n\n\n\nThere are other aesthetics that we can add, such as size, colour, shape, group, etc. We will use these later in this section.\n3.2.3 Layer 3: geometry\nGeometry is the type of plot/object we want to create. In our casewe want to create a scatterplot, by using geom_point() function:\n\nggplot(data = gapminder,\n    aes(x = gdpPercap, y = lifeExp)) + \n    geom_point()\n\n\n\n\nWe now have our first plot. There other geometry types in ggplot depending on the type of data you have\n\ngeom_point() : for sactterplots\ngeom_line() : for line plots\ngeom_histogram() : for histogram\ngeom_area() : for area charts\ngeom_boxplot() : for boxplots\ngeom_bar() : for bar graphs\n\nIn the code above, we have three steps to create a plot:\n\nggplot(data = gapminder): we are simply telling ggplot that we are using gapminder dataset\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)): we are adding mapping aesthetics or aesthetics, allocating x, y axis.\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + geom_point(): We have added a geometry layer through geoms_point() function to create a scatterplot.\n3.2.4 Layer 4: Labels\nggplot2 package can handle various plot labels, including axis titles and graph titles. We can do this using labs() function:\n\nggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp)) + \n  geom_point() +\n  labs(x = \"GDP per capita (log scale)\",\n       y = \"Life expectancy\",\n       title = \"GDP vs Life Expectancy (1952-2007)\",\n       subtitle = \"People in developed countries tend to live longer\",\n       caption = \"Data source: Gapminder\")\n\n\n\n\n3.2.5 Facets\nFaceting is used when we’d like to split a particular visualization by the values of another variable. This will create multiple copies of the same type of plot with matching x and y axes, but whose content will differ.\nWhen we one to split the plots into various sub-categories, by using a categorical variable, we use facet_wrap() function. For example, we may want to split the above plot by continent:\n\nggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp)) + \n  geom_point() +\n  facet_wrap(~continent)\n\n\n\n\nThere are other argument that comes with facet_wrap() function. We can specify tghe number of rows and columns, using nrow() and ncol() functions, respectively.\n\nggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp)) + \n  geom_point() +\n  facet_wrap(~continent, ncol = 5)\n\n\n\n\n3.2.6 Transforming axis scales\nNotice that x-axis is not normally distributed. One of the method to use is to transform data to log10, to normnalise it:\n\nggplot(data = gapminder,\n    aes(x = gdpPercap, y = lifeExp)) + \n    geom_point() +\n  scale_x_log10()\n\n\n\n\nLook how it changes.\nThere are many scales functions and you will learn them along the way by coding and exploring ggplot.\n3.2.7 Returning to aeathetics\nWe can add other aesthetics in our plot, for example, we can allocate colour to the continent column:\n\nggplot(data = gapminder,\n    aes(x = gdpPercap, y = lifeExp, colour = continent)) + \n    geom_point() +\n  scale_x_log10()\n\n\n\n\nNotice how countries in Europe tend to have higher GDP per capita and and higher life expectancy compared to African countries.\nWe can also change the shape of points in the aesthetics:\n\nggplot(data = gapminder,\n    aes(x = gdpPercap, y = lifeExp, colour = continent, shape = continent)) + \n    geom_point() +\n  scale_x_log10()\n\n\n\n\nThere are many other aesthetics arguments that are used and they are beyond the scope of this course. It takes practice.\n3.2.8 Themes\nTry experimenting with different themes that comes with ggplot. theme_minimal() will produce a minimalist theme with less background:\n\nggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp, colour = continent)) + \n  geom_point() +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log scale)\",\n       y = \"Life expectancy\",\n       title = \"GDP vs Life Expectancy (1952-2007)\",\n       subtitle = \"People in developed countries tend to live longer\",\n       caption = \"Data source: Gapminder\") +\n  theme_minimal()\n\n\n\n\nThere are other themes that can transform your plots to look more elegant.\nYou can also choose the how fonts appear using themes() function:\n\nggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp, colour = continent)) + \n  geom_point() +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log scale)\",\n       y = \"Life expectancy\",\n       title = \"GDP vs Life Expectancy (1952-2007)\",\n       subtitle = \"People in developed countries tend to live longer\",\n       caption = \"Data source: Gapminder\") +\n  theme(text = element_text(size = 15))\n\n\n\n\nWith themes() function, you can remove borders, change the colour of fonts, remove the legend, etc."
  },
  {
    "objectID": "weeks/week-2.html#visualising-numerical-data",
    "href": "weeks/week-2.html#visualising-numerical-data",
    "title": "3 Data Visualisation",
    "section": "3.3 Visualising Numerical data",
    "text": "3.3 Visualising Numerical data\n3.3.1 Single variable\nFor visualising one variable, we mostly histogram, density plot, etc:\nCreate a histogram of GDP per capita:\n\nggplot(data = gapminder, aes(gdpPercap)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nWe can see that the GDP per capita variable is skewed. Density plots are also similar to histograms:\n\nggplot(data = gapminder, aes(gdpPercap)) +\n  geom_density()\n\n\n\n\n3.3.2 Visualising more than one numerical variables\nA scatter plot is used to show relationship between two variables\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) + \n    geom_point()\n\n\n\n\nWe can add other aeasthetics such as shape, colour etc: Let’s add the colour aesthetics:\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp, colour = continent)) + \n    geom_point()\n\n\n\n\nWe can change the add the size aesthetics and use population of the country:\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp, colour = continent, size = pop)) + \n  geom_point()\n\n\n\n\n3.3.3 Visualising numerical by group/category\nA boxplot is useful when we want to view statistics by a particular group, let say, GDP by continent:\n\nggplot(data = gapminder, aes(x = continent, y = gdpPercap)) +\n  geom_boxplot()\n\n\n\n\nWe can also use a column chart, let say, view GDP per capita by continent:\n\nggplot(data = gapminder, aes(x = continent, y = gdpPercap)) +\n  geom_col()\n\n\n\n\n3.3.4 visualise trends\nWe mainly use line graphs to visualise statistics over time. Let use see how life expectancy changes over time\n\nggplot(data = gapminder, aes(x = year, y = lifeExp, group = country)) +\n  geom_line()\n\n\n\n\nThis looks ugly, but we will learn how to create proper line plots at the end.\nYou can also use stacked column chart:\n\nggplot(data = gapminder, aes(x = year, y = pop, fill = continent)) +\n  geom_col()\n\n\n\n\nView by continent and make it 100% stacked bar\n\nggplot(data = gapminder, aes(x = year, y = pop, fill = continent)) +\n  geom_col(position = \"fill\")\n\n\n\n\nYou can make horizontal bars by using coord_flip():\n\nggplot(data = gapminder, aes(x = year, y = pop, fill = continent)) +\n  geom_col(position = \"fill\") +\n  coord_flip()"
  },
  {
    "objectID": "weeks/week-2.html#visualising-categoricalcharacter-data",
    "href": "weeks/week-2.html#visualising-categoricalcharacter-data",
    "title": "3 Data Visualisation",
    "section": "3.4 Visualising categorical/character data",
    "text": "3.4 Visualising categorical/character data\nIn the gapminder dataset, we have two categorical columns: country and continent. One of the plot used for handling categorical data is bar chart. In ggplot, we use geom_bar:\n\nggplot(data = gapminder, aes(x = continent)) + \n  geom_bar()\n\n\n\n\nBonus one: Interactive charts\nYou can make your charts interactive by using plotly package, you will need to install it first\n\ninstall.packages(plotly)\n\nThen load the package:\n\nlibrary(plotly)\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\n\nFirst, create a plot using ggplot() and save it using the &lt;- operator:\n\nfirst_plot &lt;- ggplot(data = gapminder,\n       aes(x = gdpPercap, y = lifeExp, colour = continent)) + \n  geom_point() +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log scale)\",\n       y = \"Life expectancy\",\n       title = \"GDP vs Life Expectancy (1952-2007)\",\n       subtitle = \"People in developed countries tend to live longer\",\n       caption = \"Data source: Gapminder\") +\n  theme_minimal() \n\nWe named the plot first_plot. From the plotly package, you going to use ggplotly() function and put the plot object you have created:\n\nggplotly(first_plot)\n\n\n\n\n\nExperiment with the results, when you hoover around the plot, you can see it shows information by variable. You can select which continent to make visible by clicking on the legend. Beautiful!\nBonus Two: Animate\nYou can create an animated chart using the gganimate package. Install first:\n\ninstall.packages(gganimate)\n\nLoad the package:\n\nlibrary(gganimate)\n\nYou would want to see how the life expectancy and gdp per capita changes over time. First create the plot, but add few functions:\n\nanimated_plot &lt;- ggplot(data = gapminder,\n       aes(x = gdpPercap, \n           y = lifeExp, \n           size = pop,\n           colour = continent)) + \n  geom_point() +\n  scale_x_log10() +\n  labs(x = \"GDP per capita (log scale)\",\n       y = \"Life expectancy\",\n       title = \"GDP vs Life Expectancy (1952-2007)\",\n       subtitle = 'Year: {frame_time}',\n       caption = \"Data source: Gapminder\") +\n  theme_minimal() +\n  transition_time(year) +\n  ease_aes('linear') \n\n\nanimate(animated_plot)\n\n\n\n\nLook at the results!\nThis section introduced you to basics of data visualisation using ggplot2 package. You may need to consult the following materials for intermediate and advanced skills in data visualisation:\n\nHealy, K. (2018). Data visualization: a practical introduction. Princeton University Press\nThe R Graph Gallery\nR for Data Science. Chapter 10-12\nData visualisation with ggplot2: cheatsheet"
  },
  {
    "objectID": "weeks/week-1a.html",
    "href": "weeks/week-1a.html",
    "title": "Introduction to Python Programming",
    "section": "",
    "text": "understand the basics of Python programming\nUnderstand data types and objects\nunderstand Python functions"
  },
  {
    "objectID": "weeks/week-1a.html#learning-objectives",
    "href": "weeks/week-1a.html#learning-objectives",
    "title": "Introduction to Python Programming",
    "section": "",
    "text": "understand the basics of Python programming\nUnderstand data types and objects\nunderstand Python functions"
  },
  {
    "objectID": "weeks/week-1a.html#reading",
    "href": "weeks/week-1a.html#reading",
    "title": "Introduction to Python Programming",
    "section": "Reading",
    "text": "Reading"
  },
  {
    "objectID": "weeks/week-1a.html#basics-of-python",
    "href": "weeks/week-1a.html#basics-of-python",
    "title": "Introduction to Python Programming",
    "section": "Basics of Python",
    "text": "Basics of Python\nIn the previous section, we showed the layout of RStudio. For this lesson, you will write all the code in the scripts/source and see the output in the console. To comment on the code, you will use the hashtag (#) to tell R not to execute the line as a code.\nR can be used as a calculator:\n\nprint(4 + 7) \n\nprint(9 * 6) \n\n11\n54\n\n\n\nArithmetic Operators\n\n\n\nDescription\nOperator\nExample\n\n\n\n\nAddition\n+\n1 + 3\n\n\nSubtract\n-\n90 - 5\n\n\nMultiplication\n*\n6 * 7\n\n\nExponentiation\n**\n3 ^ 6\n\n\nDivision\n/\n54 / 7\n\n\n\nType in and run the above examples in the script or console.\n\n\nAssigning variables\nNotice that we have been running previous codes without assigning them to a variable. We can assign anything to a variable (=); this can be a plot, a variable, a table, etc.\nSay we ages of two individuals: Thembi’s age is 30 and Sipho’s age is 20. You can assign their ages to a variable:\n\nthembi_age = 30\n\nsipho_age = 20\n\nYou can use print() function to get the results\n\nprint(thembi_age)\n\nprint(sipho_age)\n\n30\n20\n\n\nBecause you have stored/assigned these into variables, you can calculate, let’s say, total, differences, multiplication, etc. Get the sum of ages:\n\nsipho_age + thembi_age\n\n50\n\n\nGet age differences:\n\nthembi_age - sipho_age\n\n10\n\n\nMultiply these ages:\n\nthembi_age * sipho_age\n\n600\n\n\nBasically, we have crated variables: sipho_age and thembi_age, and stored their ages in numbers there. always remember this:\n\na variable name is case sensitive: if you have named it sipho_age, when you type Sipho_age there will be an error:\n\n\nprint(Sipho_age)\n\nNameError: name 'Sipho_age' is not defined\n\n\n\n\nData types in Python\nWhile there many data types in Python, in this course, we will focus on the most common:\nThere 3 basic data types in R\n\nnumeric:\n\nint: integers eg. (1, 2, 6, 90)\nfloat: with decimal e.g. (1.2, 5.3, 8.4)\n\nstring: str. This is text data, for axample, “My name is Aubrey”\nboolean: bool. TRUE/FALSE\n\n\nStrings\nStrings are character data types, alwways surrounded by quoates: either single quotes ('') or double quotes (\"\")\nExample of a string variables:\n\nriver = \"Tugela river\"\n\nprint(river)\n\nTugela river\n\n\n\ncountry  = \"South Africa\"\n\nprint(country)\n\nSouth Africa\n\n\nNotice that a string need to be surrounded by (““) every time, otherwise Python will return an error\n\nriver = Tugela_river\n\nNameError: name 'Tugela_river' is not defined\n\n\nThere are various basic analysis we can apply to string. For example, you may add two string:\n\nname = \"Peter\"\n\nsurname = \"Zulu\"\n\n### Add to strings\n\nprint(name + surname)\n\nPeterZulu\n\n\nYou can leave spaces between when adding two string variables:\n\nprint(name + \" \" + surname)\n\nPeter Zulu\n\n\nYou can convert to strings to upper or lower cases by using .upper() and .lower() functions, respectively:\n\nname.upper() \n\n'PETER'\n\n\n\nsurname.lower()\n\n'zulu'\n\n\nHow long is the string? You can find out by using len() function:\n\nlen(name)\n\n5\n\n\n\nlen(surname)\n\n4\n\n\n\n\nNumeric data\nNumeric data represent numerical values, they can be either:\n\ninterger: whole numbers (e.g. 1, 30, 5, 90) or\nfloat: numbers with decimals (e.g. 1.2, 4.7…)\n\nFor example we may create a variables of river lenght and depth in kilometers\n\nriver_length_km = 531\nprint(river_length_km)\n\nriver_depth_km = 0.15\nprint(river_depth_km)\n\n531\n0.15\n\n\nThere are many functions that can be used to analyse numeric data, for example, we may add two numeric variables:\n\nprint(river_length_km + river_depth_km)\n\n531.15\n\n\nYou can multiply:\n\nprint(river_depth_km * river_depth_km)\n\n0.0225\n\n\nNumeric data does not to need to be surrounded by \" \", if you do, they will be stored as a string.\n\n\n\nBoolean\nBoolean data takes two possible values:True or False. An example of a logical data type:\n\nis_male = True\n\nprint(is_male) \n\nis_female = False\n\nprint(is_female) \n\nTrue\nFalse\n\n\nIn many cases, booleans are used to evaluate conditions:\n\n==: Equal to\n!=: Not equal to\n&lt;: Less than\n&gt;: Greater than\n&lt;=: Less than or equal to\n&gt;=: Greater than or equal to\n\n\nage = 45\n\nprint(age == 45)\n\nTrue\n\n\n\nage = 45\nprint(age &gt; 50)\n\nFalse\n\n\n\nage = 45\nprint(age &gt; 50)\n\nFalse\n\n\n\nage = 45\n\nif age &gt; 34:\n    print(\"This person is an adult\")\nelse: \n        print(\"You are young\")\n\nThis person is an adult\n\n\n\nWhat type?\nYou can ask python to tell you the type of the data structure by using type() function:\n\nriver_length_km = 531\nprint(type(river_length_km))\n\n&lt;class 'int'&gt;\n\n\nThe river_lenght_km variable is an integer\n\nriver_name = \"Tugela\"\n\nprint(type(river_name))\n\n&lt;class 'str'&gt;\n\n\n\nis_female = False\n\nprint(type(is_female))\n\n&lt;class 'bool'&gt;\n\n\nIn this section, you have learnt basic data types, functions and operators. Next, we learn different type of data structures."
  },
  {
    "objectID": "my-profile.html",
    "href": "my-profile.html",
    "title": "About Me",
    "section": "",
    "text": "I am a social scientist and human geographer, currently completing a PhD thesis on geographies of youth in Durban. I lecture in the School of Education, University of KwaZulu Natal, Pietermaritzburg Campus. My research interests in:\n\nDevelopment (political economy, geographies, Polanyi)\nSocial Data Science\nComputational social science\nNeighbourhood contexts (education outcomes, health, deprivation)\nYouth studies\nSocial theory (Foucault ❤️, Agamben, governance, markets)\nPolitical geography and political participation (protest, elections, behaviour)\n\nI use data science tools, computational methods and statistical methods in my research. I enjoy programming in R and Python."
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "For beginners, I recommend that you set up Python in Anacoda. You will also use VScode IDE for interacting with Python. An IDE makes it easier to code interactively. To set up everything (Anaconda, Python and VSCode) that will be required for this course, please visit this resource and got to “Prerequisites” section.\nAfter installing everything, you should be able to start coding."
  },
  {
    "objectID": "getting-started.html#installing-python",
    "href": "getting-started.html#installing-python",
    "title": "Getting Started",
    "section": "",
    "text": "For beginners, I recommend that you set up Python in Anacoda. You will also use VScode IDE for interacting with Python. An IDE makes it easier to code interactively. To set up everything (Anaconda, Python and VSCode) that will be required for this course, please visit this resource and got to “Prerequisites” section.\nAfter installing everything, you should be able to start coding."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python for Data Science: A gentle introduction",
    "section": "",
    "text": "These workshops aim to introduce participants to the foundations of data science using Python programming Language. As you advance in our studies and career, you will learn that the ability to collect, clean, transform, analyse and use data for predictive analytics is one of the most needed skills in the labour market. As we live in the digital age, where big data has become a commodity, learning to handle these data systems will be one of the most important investments in your career.\nIn this course, we will be using Python for programming and data analysis. Python along with R, is flexible when working with data, especially large data. Majority of academics, researchers, and students who analyse quantitative data use programs such as SPSS, STATA and Excel. However, these programs are expensive! Universities spend large sums of money to purchase these licences, which disadvantages students and academics in the developing world. They are also very limited in handling various data formats such as big data, text data, geospatial data, etc. But if you insist on learning them, good for you.\n\nOn the other hand, Python and R are free and come with with ABSOLUTELY NO WARRANTY 😎 . They are very flexible and can handle very large data. They are the dominant programming languages used in the labour market around the world. Python and R have thousands of libraries that can handle and analyse any type of data, including basic data cleaning and wrangling, transforming data, regression, visualisation, text analysis and natural language processing, statistical analysis, machine learning, geospatial analysis and visualisation. In academia, researchers are encouraged to make their research outputs Reproducible, that is, researchers must share code, data and analysis when submitting papers to journals. This is called Reproducible Science.\nBoth Python and R are awesome programming languages. In this course we will be working with Python. If you are interested in R, there is another course that I have designed for you, you can access it here"
  },
  {
    "objectID": "index.html#an-invitation-to-python-for-data-science",
    "href": "index.html#an-invitation-to-python-for-data-science",
    "title": "Python for Data Science: A gentle introduction",
    "section": "",
    "text": "These workshops aim to introduce participants to the foundations of data science using Python programming Language. As you advance in our studies and career, you will learn that the ability to collect, clean, transform, analyse and use data for predictive analytics is one of the most needed skills in the labour market. As we live in the digital age, where big data has become a commodity, learning to handle these data systems will be one of the most important investments in your career.\nIn this course, we will be using Python for programming and data analysis. Python along with R, is flexible when working with data, especially large data. Majority of academics, researchers, and students who analyse quantitative data use programs such as SPSS, STATA and Excel. However, these programs are expensive! Universities spend large sums of money to purchase these licences, which disadvantages students and academics in the developing world. They are also very limited in handling various data formats such as big data, text data, geospatial data, etc. But if you insist on learning them, good for you.\n\nOn the other hand, Python and R are free and come with with ABSOLUTELY NO WARRANTY 😎 . They are very flexible and can handle very large data. They are the dominant programming languages used in the labour market around the world. Python and R have thousands of libraries that can handle and analyse any type of data, including basic data cleaning and wrangling, transforming data, regression, visualisation, text analysis and natural language processing, statistical analysis, machine learning, geospatial analysis and visualisation. In academia, researchers are encouraged to make their research outputs Reproducible, that is, researchers must share code, data and analysis when submitting papers to journals. This is called Reproducible Science.\nBoth Python and R are awesome programming languages. In this course we will be working with Python. If you are interested in R, there is another course that I have designed for you, you can access it here"
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand Python and its functions\nConduct basic programming using Python\nLearn to wrangle, clean and transform data\nLearn the basics of data visualisation using matplotlib\nLearn how to conduct exploratory data analysis\nLearn to communicate and tell stories using data"
  },
  {
    "objectID": "index.html#materials",
    "href": "index.html#materials",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Materials",
    "text": "Materials\nThere are tons of materials available online; some of the most popular books include:\n\nMcKinney, W. (2022). Python for data analysis, 3rd Edition. O’Reilly Media\nVanderPlas, J. (2016). Python data science handbook: Essential tools for working with data. O’Reilly Media"
  },
  {
    "objectID": "index.html#lets-get-started",
    "href": "index.html#lets-get-started",
    "title": "Python for Data Science: A gentle introduction",
    "section": "Let’s Get Started",
    "text": "Let’s Get Started"
  },
  {
    "objectID": "weeks/week-1b.html",
    "href": "weeks/week-1b.html",
    "title": "2 Data Structures in Python",
    "section": "",
    "text": "In this chapter we deal with different data structures that can hold data in Python. Specifically, we will focus on the follwoing data structures:\n\nLists\nTuples\nDictionaries\nDataFrames\n\n\nLists\nList is a data structure that store a collection of elements/items within it. For example, in previous chapter we created a string variable named country that contained “South Africa” element:\n\ncountry = \"South Africa\"\n\nprint(country)\n\nSouth Africa\n\n\nWhat if we wanted to create another country variable, named country_2 with “Zimbabwe” as an element? We can also do this:\n\ncountry_2 = \"Zimbabwe\"\nprint(country_2)\n\nZimbabwe\n\n\nWhat if we want to add country_3, country_4, etc? We can end up having many variables. This where lists come in. Lists are used to hold many items together. you can create lists in Python by using square barackets ([]):\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nWe now have a list of all countries in the Southern African region. There are various functions that can be used to extract, analyse and manipulate elements in a list. For example, you may be interested on how many elements are in a lists; in our case, how many countries are in the southern_african_countries list. You can use the len() function:\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(len(southern_african_countries))\n\n10\n\n\nThe list has 10 elements/items.\n\nSubset a list\nYou can extract the list item by using the [] and the index position of the item. Note that Python index start at 0, meaning the first element will be in the position 0. This is important especially when coming from R background. Let extract the first element:\n\nprint(southern_african_countries[0])\n\nAngola\n\n\nThe first element is Angola.\nYou can use can access the last element by:\n\nprint(southern_african_countries[-1])\n\nZimbabwe\n\n\nYou can access more than 1 items; for example, extract the first, second and third items in the list by slicing:\n\nprint(southern_african_countries[0:3])\n\n['Angola', 'Botswana', 'Lesotho']\n\n\nNotice that we have included the index 3, which is the 4th item, although the element itself is not printed. When slicing a list, the last index mentioned is not included. This is very importnt to note. There are other slicing options:\n\nprint(southern_african_countries[:3])\n\n['Angola', 'Botswana', 'Lesotho']\n\n\n\n\nManipulate a list\nList elements can be changed. For example, in 2018 Zwaziland changed their name to “eSwatini”. We can change this in a list. First re-create the list:\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nThen change the list element:\n\nsouthern_african_countries[7] = \"eSwatini\"\nprint(southern_african_countries)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe']\n\n\nWe have changed the list element from “Swaziland” to “Eswatini”.\nYou can also add new elements in a list. Suppose a geographer told us that our list of Southern African countries missed 3 countries: Democratic Republic of the Congo, Mauritius, Madagascar and Seychelles. In Python, we can update our list and assign it to anew variable called southern_africa_updated. First find the length of the original southern_african_countries:\n\nlen(southern_african_countries)\n\n10\n\n\nAdd new items:\n\nsouthern_africa_updated = southern_african_countries + [\"Democratic Republic of the Congo\", \"Mauritius\", \"Madagascar\", \"Seychelles\"]\n\nprint(southern_africa_updated)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe', 'Democratic Republic of the Congo', 'Mauritius', 'Madagascar', 'Seychelles']\n\n\nFind the lenght of the updated variable:\n\nlen(southern_africa_updated)\n\n14\n\n\nThe updated variable has lenght of 14. This means we have added 4 items.\nYou can remove an element from the list by using del() function:\n\ndel southern_africa_updated[0]\n\nprint(southern_africa_updated)\n\n['Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'eSwatini', 'Zambia', 'Zimbabwe', 'Democratic Republic of the Congo', 'Mauritius', 'Madagascar', 'Seychelles']\n\n\nWe have removed the element at the index 0, which is Botswana.\n\n\nManipulating list with numeric data\nIn above examples we have worked with list that contain string data types: all out elements were string (country names). Suppose we have the life expectancy of those countries. Life expectancy is the average number of years is expected to live:\nLet us create a numeric list, that we name life_expectancy, that has the average life expectancy of the countries of Southern Africa:\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\nprint(life_expectancy)\n\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nWe can find the minimum life expactancy:\n\nprint(min(life_expectancy))\n\n53.1\n\n\nPrint the maximum life expectancy:\n\nprint(max(life_expectancy))\n\n62.9\n\n\nNot that a list can hold elements of of different data types: string, float, integer, boolean, etc.\nperson_1 = [“Name”, “Aubrey”, “Age”, 32, “Height”, 1.8, “Is male?”, True] print(person_1) ```\n\n\nNumPy Arrays\nA NumPy array is a data structure that can hold numeic elements. It is short for Numeric Python. It is an important data structure if you want to manipulate numeric data. First, you will need to install the numpy package if not already installed:\n\npip install numpy\n\nThen load the library as:\n\nimport numpy as np\n\nSuppose we have the lenght in kilometers of major South Africa rivers stored as a list and assigned it to river_lenght_km variable:\n\nriver_lenght_km = [2200, 1800, 1210, 502, 560, 645, 520, 480]\nprint(river_lenght_km)\n\n[2200, 1800, 1210, 502, 560, 645, 520, 480]\n\n\nWe need to convert this lift into an numpy array:\n\nriver_lenght_km = np.array(river_lenght_km)\n\nprint(type(river_lenght_km))\n\n&lt;class 'numpy.ndarray'&gt;\n\n\n\nSummary statistics and mathematical operations\nThere many functions within the numpy library. We can calculate summary statistics:\nGet the mean/average:\n\nprint(np.mean(river_lenght_km))\n\n989.625\n\n\nGet the median:\n\nprint(np.median(river_lenght_km))\n\n602.5\n\n\nGet the standard deviation:\n\nprint(np.std(river_lenght_km))\n\n631.6316049526021\n\n\nThere are other functions you can use.\nWhat are the rivers that have lenght of greater than 1000 kilometers? Find these and assign the result to a variable named longest_rivers\n\nlongest_rivers = river_lenght_km[river_lenght_km &gt; 1000]\nprint(longest_rivers)\n\n[2200 1800 1210]\n\n\nThe river_lenght_km array is in kilometers. What if we want to convert to meters? Since 1 km = 1000 meters, you can convert kilometer to meter by multplying by 1000 since. Let’s do this and assign result to a new variable named river_lenght_meters\n\nriver_lenght_meters = river_lenght_km * 1000\n\nprint(river_lenght_meters)\n\n[2200000 1800000 1210000  502000  560000  645000  520000  480000]\n\n\nJust like lists, you can subsets numpy arrays using index positions of the element. To acces the second element of river_lenght_km:\n\nprint(river_lenght_km[1])\n\n1800\n\n\nYou can sort elements into ascending or descending order:\n\nnp.sort(river_lenght_km)\n\narray([ 480,  502,  520,  560,  645, 1210, 1800, 2200])\n\n\nSort into descending\n\nnp.sort(river_lenght_km)[::-1]\n\narray([2200, 1800, 1210,  645,  560,  520,  502,  480])\n\n\nNote that NumPy arrays can also be 2 dimensional; 2D arrays is a matrix like data with rows and columns:\n\ntwo_d_array = np.array([[1, 2, 3],\n                   [4, 5, 6],\n                   [7, 8, 9]])\n\nprint(two_d_array)\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n\n\n\n\n\n\nDictionaries\nRemeember we created two lists previously, southern_african_countries and life_expectancy.\n\nsouthern_african_countries = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(southern_african_countries)\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\nprint(life_expectancy)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nWe can find the corresponding life expectancy of, for example, “Botswana”. First find the index position of Botswana:\n\nbotswana_index = southern_african_countries.index(\"Botswana\")\n\nprint(botswana_index)\n\n1\n\n\nThe index of Botswana is 1. We can access the corresposing life expectancy:\n\nlife_expectancy[botswana_index]\n\n61.1\n\n\nThe life expectancy of Botswana. But this is not efficient if we have large data. This where dictionaries come in:\n\nsouthern_africa = {\"Angola\":61.6, \n                   \"Botswana\":61.1,\n                   \"Lesotho\":57.1,\n                   \"Malawi\":53.1,\n                   \"Mozambique\":62.9,\n                   \"Namibia\":59.3}\n\nprint(southern_africa)\n\n{'Angola': 61.6, 'Botswana': 61.1, 'Lesotho': 57.1, 'Malawi': 53.1, 'Mozambique': 62.9, 'Namibia': 59.3}\n\n\nWe have created a dictionary named southern_africa. A dictionary has keys and values and this is always in pairs. For example, we have Angola as a key with its corresponding value 61.6.\nYou can find values of each keys:\n\nprint(southern_africa[\"Malawi\"])\n\n53.1\n\n\nOf Namibia:\n\nprint(southern_africa[\"Namibia\"])\n\n59.3\n\n\nYou can find keys of all keys:\n\nprint(southern_africa.keys())\n\ndict_keys(['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia'])\n\n\nIf you look at the southern_africa dictionary, we did not include all other countries in the region. We may need to add, let say, Zimbabwe:\n\nsouthern_africa[\"Zimbabwe\"] = 59.3\n\nprint(southern_africa)\n\n{'Angola': 61.6, 'Botswana': 61.1, 'Lesotho': 57.1, 'Malawi': 53.1, 'Mozambique': 62.9, 'Namibia': 59.3, 'Zimbabwe': 59.3}\n\n\nYou can see that the dictionary has been updated to include Zimbwabwe.\nSuppose demographer pouint out that the values of Botswana is outdated; that the life expectancy of the country has increased from 61.1 to 63! We can update this information\n\nsouthern_africa[\"Botswana\"] = 63\n\nprint(southern_africa[\"Botswana\"])\n\n63\n\n\nThe value of Botswana has been changed.\nWhat if we want to add new information in the dictionary? For example, we may want to add the capital cities of the countries in the southern_africa dicitionary:\n\nsouthern_africa_2 = {\"Angola\": {\"life_expectancy\": 61.6, \"capital\":\"Luanda\"},\n                     \"Botswana\": {\"life_expectancy\": 61.1, \"capital\":\"Gaborone\"},\n                     \"Lesotho\": {\"life_expectancy\": 57.1, \"capital\":\"Maseru\"},\n                     \"Malawi\": {\"life_expectancy\": 53.1, \"capital\":\"Lilongwe\"},\n                     \"Mozambique\": {\"life_expectancy\": 62.9, \"capital\":\"Maputo\"},\n                     \"Namibia\": {\"life_expectancy\": 59.3, \"capital\":\"Windhoek\"}}\n\nprint(southern_africa_2)\n\n{'Angola': {'life_expectancy': 61.6, 'capital': 'Luanda'}, 'Botswana': {'life_expectancy': 61.1, 'capital': 'Gaborone'}, 'Lesotho': {'life_expectancy': 57.1, 'capital': 'Maseru'}, 'Malawi': {'life_expectancy': 53.1, 'capital': 'Lilongwe'}, 'Mozambique': {'life_expectancy': 62.9, 'capital': 'Maputo'}, 'Namibia': {'life_expectancy': 59.3, 'capital': 'Windhoek'}}\n\n\nAs you can see in the results, the dictionary has been updated.\n\nDataFrames\nThe previous data structures we have discussed (lists, np.arrays, dictionaries) can handly limited amount of data. In the real world, most data comes big, in a tabular format: with columns and rows. In Python, we use we use the pandas package to handle data in a tabular format. You need to install it first:\n\npip install pandas\n\nThen import pandas:\n\nimport pandas as pd\n\nLet return to the previous lists that we have created: list of Southern African countries and corresponding life expectancy:\n\ncountry = [\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\"]\n\nprint(country)\n\n['Angola', 'Botswana', 'Lesotho', 'Malawi', 'Mozambique', 'Namibia', 'South Africa', 'Swaziland', 'Zambia', 'Zimbabwe']\n\n\nCreate life_expectancy list:\n\nlife_expectancy = [61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\nprint(life_expectancy)\n\n[61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3]\n\n\nLet’s add one more list of, for example, population of each country:\n\npopulation = [500, 600, 1000, 150, 490, 740, 300, 781, 610, 504]\n\nprint(population)\n\n[500, 600, 1000, 150, 490, 740, 300, 781, 610, 504]\n\n\nFrom these three lists, we can create a DataFrame using pandas:\n\nsouthern_africa_df = pd.DataFrame({\"country_name\":country, \"life_expect\": life_expectancy, \"pop\":population})\n\nprint(southern_africa_df)\n\n   country_name  life_expect   pop\n0        Angola         61.6   500\n1      Botswana         61.1   600\n2       Lesotho         57.1  1000\n3        Malawi         53.1   150\n4    Mozambique         62.9   490\n5       Namibia         59.3   740\n6  South Africa         59.3   300\n7     Swaziland         62.3   781\n8        Zambia         61.2   610\n9      Zimbabwe         59.3   504\n\n\nWe have a DataFrame with three columns: country_name, life_expect, and pop and 10 rows (observations), where each row represent country. You can use the .head() function to view the first observations\n\nprint(southern_africa_df.head())\n\n  country_name  life_expect   pop\n0       Angola         61.6   500\n1     Botswana         61.1   600\n2      Lesotho         57.1  1000\n3       Malawi         53.1   150\n4   Mozambique         62.9   490\n\n\nYou can check how many columns and rows in the DataFrame by using .info() function:\n\nprint(southern_africa_df.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 10 entries, 0 to 9\nData columns (total 3 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   country_name  10 non-null     object \n 1   life_expect   10 non-null     float64\n 2   pop           10 non-null     int64  \ndtypes: float64(1), int64(1), object(1)\nmemory usage: 368.0+ bytes\nNone\n\n\nYou can get more information of your DataFrame by using .describe() function, it will return the summary statistics of all numeric columns:\n\nprint(southern_africa_df.describe())\n\n       life_expect          pop\ncount    10.000000    10.000000\nmean     59.720000   567.500000\nstd       2.898582   241.687241\nmin      53.100000   150.000000\n25%      59.300000   492.500000\n50%      60.200000   552.000000\n75%      61.500000   707.500000\nmax      62.900000  1000.000000\n\n\nYou can subset both rows and columns, to return only those you are interested in. Let’s say you want to select only country_name and pop columns, you can do this by wrapping the DataFrame within double square brackets ([[]]) and specify those coulumns:\n\nprint(southern_africa_df[[\"country_name\", \"pop\"]])\n\n   country_name   pop\n0        Angola   500\n1      Botswana   600\n2       Lesotho  1000\n3        Malawi   150\n4    Mozambique   490\n5       Namibia   740\n6  South Africa   300\n7     Swaziland   781\n8        Zambia   610\n9      Zimbabwe   504\n\n\nYou can also select rows. For example, subset observations from Angola and save as a new DataFrame named angola:\n\nangola = southern_africa_df[southern_africa_df[\"country_name\"] == \"Angola\"]\n\nprint(angola)\n\n  country_name  life_expect  pop\n0       Angola         61.6  500\n\n\nSelect observations from Angola and Zimbabwe:\n\nangola_zim = southern_africa_df[southern_africa_df[\"country_name\"].isin([\"Angola\", \"Zimbabwe\"])]\nprint(angola_zim)\n\n  country_name  life_expect  pop\n0       Angola         61.6  500\n9     Zimbabwe         59.3  504\n\n\nSubset observations where life expectancy is below 60:\n\nlow_life_expect = southern_africa_df[southern_africa_df[\"life_expect\"] &lt; 60]\n\nprint(low_life_expect)\n\n   country_name  life_expect   pop\n2       Lesotho         57.1  1000\n3        Malawi         53.1   150\n5       Namibia         59.3   740\n6  South Africa         59.3   300\n9      Zimbabwe         59.3   504\n\n\nThere are many other ways in which you can manipulate, transform and analyse DataFrame, and pandas provide many methods to handle DataFrames. We will dive deepr into DataFrames and Pandas in Week 3\nIn this chapter we have discussed different data structures that can hold data:\n\nLists\nNumpy Arrays\nDictionaries\nDataFrames\n\nIn the next chapter, we explore various ways in which we can visualise data."
  },
  {
    "objectID": "weeks/week-3.html",
    "href": "weeks/week-3.html",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Understand dataframes\nManipulate, transform and analyse dataframes\n\nDataframes, as we saw the previous section, is a tabular data format, with columns and rows. Columns are variable names and rows are individual observations.\nLet us a basic data frame with three columns: country, life expectancy, and population of Southern African countries. First, we create individual vectors:\n\n# Create a character vector\ncountry_name &lt;- c(\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\")\n\ncountry_name\n\n [1] \"Angola\"       \"Botswana\"     \"Lesotho\"      \"Malawi\"       \"Mozambique\"  \n [6] \"Namibia\"      \"South Africa\" \"Swaziland\"    \"Zambia\"       \"Zimbabwe\"    \n\n## Create a numeric vector\n\nlife_expectancy &lt;- c(61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3)\n\nlife_expectancy\n\n [1] 61.6 61.1 57.1 53.1 62.9 59.3 59.3 62.3 61.2 59.3\n\n## create another numeric vector\n\npopulation &lt;- c(34500000, 2590000, 228000, 19890000, 32080000,  2530000, 59390000, 1190000, 19470000, 1599000)\n\nBecause we have 3 vectors of equal length, we can create a dataframe, using a data.frame() function:\n\nsouthern_africa_df &lt;- data.frame(country_name, life_expectancy, population) #combine two vectors to create a dataframe\n\nsouthern_africa_df ## print the dataframe\n\n   country_name life_expectancy population\n1        Angola            61.6   34500000\n2      Botswana            61.1    2590000\n3       Lesotho            57.1     228000\n4        Malawi            53.1   19890000\n5    Mozambique            62.9   32080000\n6       Namibia            59.3    2530000\n7  South Africa            59.3   59390000\n8     Swaziland            62.3    1190000\n9        Zambia            61.2   19470000\n10     Zimbabwe            59.3    1599000\n\n\nA dataframe is basically made of vectors (columns). In the southern_africa_df dataframe, we have 3 columns: country_name, life_expectancy population. We can extract these elements using the $ sign:\n\nsouthern_africa_df$country_name\n\n [1] \"Angola\"       \"Botswana\"     \"Lesotho\"      \"Malawi\"       \"Mozambique\"  \n [6] \"Namibia\"      \"South Africa\" \"Swaziland\"    \"Zambia\"       \"Zimbabwe\"    \n\nsouthern_africa_df$life_expectancy\n\n [1] 61.6 61.1 57.1 53.1 62.9 59.3 59.3 62.3 61.2 59.3\n\nsouthern_africa_df$population\n\n [1] 34500000  2590000   228000 19890000 32080000  2530000 59390000  1190000\n [9] 19470000  1599000\n\n\n\nWe will use the dplyr package to manipulate data. dplyr is part of tidyverse meta-package and is mostly used to clean, manipulate and transform dataframes. dplyr has 5 main verbs/functions:\n\nselect(): for selecting particular columns in a dataframe\nfilter(): for sub-setting rows based on the specified criteria\narrange(): sort rows/observations based (ascending/descending)\nsummarise(): for summary statistics\nmutate(): create new columns based on the manipulation of the existing columns.\ngroup_by(): get aggregate statistics by a category\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nYou can also load dplyr by loading the tidyverse package; this will load all the packages in in `tidyverse at once. This is useful, for example, when you want to clean and visualise data:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ stringr 1.5.0\n✔ tidyr   1.3.0     ✔ forcats 1.0.0\n✔ readr   2.1.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nNote that you will net to install tidyverse if you did not install it from the previous section:\n\n\nWarning: package 'tidyverse' is in use and will not be installed\n\n\nLet us load the gapminder dataset that we used from the previous week. If you did not install, you will need to do so.\n\nlibrary(gapminder)\n\nThan assign it to the object, gapminder, using the &lt;- operator:\n\ngapminder &lt;- gapminder\n\nWrite the following code to change the country and continent from factor to character, I will explain this in the next chapter:\n\ngapminder$country &lt;- as.character(gapminder$country)\n\ngapminder$continent &lt;- as.character(gapminder$continent)\n\nNow you have an object, which is a dataframe, called gapminder, you can see it in the Environment pane in RStudio. It shows that it has ncol(gapminder) columns/variables and nrow(gapminder) observations/rows\n\n\ngapminder dataframe in Environment pane\n\nYou can use the str() fucntion to get the structure of the dataframe:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nWe have 6 variables:\n\n“country”\n“continent”\n“year”\n“lifeExp”: life expectancy of a country\n“pop”: population\n“gdpPercap”: GDP per capita\n\nYou can get a sample of the first observations/rows using head() function:\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\nWe may be interested in some of the columns in the gampminder dataframe, let say, for example, “country” and “pop” variables and discard others; we use the select() function:\n\nlibrary(dplyr)\nselect(gapminder, \"country\", \"pop\")\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nR return only the country and population variables. select() function only return the variables/columns we are interested in:\n\n\nThe best way to work with R, esepcially tidyverse, is using the pipe (|&gt;) operator. The pipe connect various tasks, for example:\n\ngapminder |&gt;\n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nThe pipe chains your operations. It says:\n\nTake gapminder dataframe\nThen using the select() function to select only pop and country columns\n\nYou will that pipe becomes important when having multiple chains of functions at once.\nYou will notice that in other sources: web, books, etc. have %&gt;% instead of |&gt;. It works the same way. The |&gt; is new. %&gt;% comes from mgttr, an external package, so you needed to load it first before using it. The native pipe |&gt; is built in R, so it there is no need to load it. So, we will stick with the |&gt;.\nIn your RStudio, follow these instructions:\n\nGo to ‘Tools’ and click on ‘Global Options’\nNavigate to ‘Code’ on the left pane\nThen select the fourth option, “use native pipe operator, |&gt;”\nClick ‘Apply’\n\nYou can use the short cut Ctrl + Shift + M If you using Windows to insert the pipe instead of typing it. If you are using Mac, use Cmd + Shift + M.\n\nAs I have said, select() only return the columns specified\n\ngapminder %&gt;% \n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nAlso, notice that we selected “country’ and”pop” columns but did not save them and assigned to an object. To store the results into an object, we have to use assignment operator (&lt;-):\n\ngapminder_selected &lt;- gapminder |&gt;\n  select(country, pop)\n\ngapminder_selected # print\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nNow we have saved results as gapminder_selected, and we can do other analysis with this object because we have saved it. So, in a nutshell, when you run a code without assigning results into an object, using the &lt;- operator, results will not be saved but will be printed.\nYou can also select columns based by index/position. Let us select only 1st and 3rd coulmns\n\ngapminder |&gt; \n  select(1, 3)\n\n# A tibble: 1,704 × 2\n   country      year\n   &lt;chr&gt;       &lt;int&gt;\n 1 Afghanistan  1952\n 2 Afghanistan  1957\n 3 Afghanistan  1962\n 4 Afghanistan  1967\n 5 Afghanistan  1972\n 6 Afghanistan  1977\n 7 Afghanistan  1982\n 8 Afghanistan  1987\n 9 Afghanistan  1992\n10 Afghanistan  1997\n# ℹ 1,694 more rows\n\n\nOr you can select a range of columns\n\ngapminder |&gt; \n  select(country:year)\n\n# A tibble: 1,704 × 3\n   country     continent  year\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;\n 1 Afghanistan Asia       1952\n 2 Afghanistan Asia       1957\n 3 Afghanistan Asia       1962\n 4 Afghanistan Asia       1967\n 5 Afghanistan Asia       1972\n 6 Afghanistan Asia       1977\n 7 Afghanistan Asia       1982\n 8 Afghanistan Asia       1987\n 9 Afghanistan Asia       1992\n10 Afghanistan Asia       1997\n# ℹ 1,694 more rows\n\n\nHere, we have select columns from country to year only.\nYou can also exclude certain columns by simply adding the minus (-) sign; let say we want to exclude the gdpPercap from the dataframe\n\ngapminder |&gt; \n  select(-gdpPercap)\n\n# A tibble: 1,704 × 5\n   country     continent  year lifeExp      pop\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;\n 1 Afghanistan Asia       1952    28.8  8425333\n 2 Afghanistan Asia       1957    30.3  9240934\n 3 Afghanistan Asia       1962    32.0 10267083\n 4 Afghanistan Asia       1967    34.0 11537966\n 5 Afghanistan Asia       1972    36.1 13079460\n 6 Afghanistan Asia       1977    38.4 14880372\n 7 Afghanistan Asia       1982    39.9 12881816\n 8 Afghanistan Asia       1987    40.8 13867957\n 9 Afghanistan Asia       1992    41.7 16317921\n10 Afghanistan Asia       1997    41.8 22227415\n# ℹ 1,694 more rows\n\n\n\nYou may be interested in observations/rows that meet certain conditions. We use filter() function to return the list that meet our conditions. filter() has several operators:\n\n==: equal to\n!=: not equal to\n&gt;: greater than\n&lt;: less than\n&gt;=: greater than or equal to\n&lt;=: less than or equal to\n\nLet us filter based on the continent column. How many continent are there? Create a basic table first\n\ntable(gapminder$continent)\n\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nThere are five continents. Let us filter only observations from the African continent:\n\nafrica_gapminder &lt;- gapminder |&gt; \n  filter(continent == \"Africa\")\n\nafrica_gapminder  # print \n\n# A tibble: 624 × 6\n   country continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;   &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# ℹ 614 more rows\n\n\nafrica_gapminder object is a dataframe we have just created, with only countries from the African continent. What filter() does is to return observations/rows that only meet our conditions:\n\nLet us filter a numeric column; for example, we may want to filter countries with population of above 50 million and assign results to an object named high_pop:\n\nhigh_pop &lt;- gapminder |&gt; \n  filter(pop &gt; 50000000)\n\nhigh_pop ## print\n\n# A tibble: 190 × 6\n   country    continent  year lifeExp       pop gdpPercap\n   &lt;chr&gt;      &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Bangladesh Asia       1957    39.3  51365468      662.\n 2 Bangladesh Asia       1962    41.2  56839289      686.\n 3 Bangladesh Asia       1967    43.5  62821884      721.\n 4 Bangladesh Asia       1972    45.3  70759295      630.\n 5 Bangladesh Asia       1977    46.9  80428306      660.\n 6 Bangladesh Asia       1982    50.0  93074406      677.\n 7 Bangladesh Asia       1987    52.8 103764241      752.\n 8 Bangladesh Asia       1992    56.0 113704579      838.\n 9 Bangladesh Asia       1997    59.4 123315288      973.\n10 Bangladesh Asia       2002    62.0 135656790     1136.\n# ℹ 180 more rows\n\n\nYou can also combine 2 conditions. Let us say we want:\n\ncountries in Africa\nthe year 2007\n\n\nafrica_2007 &lt;- gapminder |&gt; \n  filter(continent == \"Africa\", year == 2007)\n\nFilter rows from the Africa OR Asia\n\ngapminder |&gt; \n  filter(continent == \"Africa\" | continent == \"Asia\")\n\n# A tibble: 1,020 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,010 more rows\n\n\nSometimes you may need to filter multiple rows, let say, more than 5 countries. It would be inconvinient to type country == \"...\" five times. This is where the %in% operator is useful:\n\nafrica_2007 |&gt; \n  filter(country %in% c(\"South Africa\", \"Zimbabwe\", \"Ghana\", \"Tanzania\", \"Tunisia\"))\n\n# A tibble: 5 × 6\n  country      continent  year lifeExp      pop gdpPercap\n  &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Ghana        Africa     2007    60.0 22873338     1328.\n2 South Africa Africa     2007    49.3 43997828     9270.\n3 Tanzania     Africa     2007    52.5 38139640     1107.\n4 Tunisia      Africa     2007    73.9 10276158     7093.\n5 Zimbabwe     Africa     2007    43.5 12311143      470.\n\n\n\narrange() function is self-explanatory: it sort values into ascending or descending order\n\nafrica_2007 |&gt; \n  arrange(lifeExp) |&gt; \n  head(n = 10) ## show the first 10 observations\n\n# A tibble: 10 × 6\n   country                  continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;                    &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Swaziland                Africa     2007    39.6  1133066     4513.\n 2 Mozambique               Africa     2007    42.1 19951656      824.\n 3 Zambia                   Africa     2007    42.4 11746035     1271.\n 4 Sierra Leone             Africa     2007    42.6  6144562      863.\n 5 Lesotho                  Africa     2007    42.6  2012649     1569.\n 6 Angola                   Africa     2007    42.7 12420476     4797.\n 7 Zimbabwe                 Africa     2007    43.5 12311143      470.\n 8 Central African Republic Africa     2007    44.7  4369038      706.\n 9 Liberia                  Africa     2007    45.7  3193942      415.\n10 Rwanda                   Africa     2007    46.2  8860588      863.\n\n\nThe default sorting is ascending order; you can sort into descending order by using desc() function within arrange():\n\nafrica_2007 |&gt; \n  arrange(desc(lifeExp)) |&gt; \n  head(n = 10) ## show the first 10 observations\n\n# A tibble: 10 × 6\n   country               continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;                 &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Reunion               Africa     2007    76.4   798094     7670.\n 2 Libya                 Africa     2007    74.0  6036914    12057.\n 3 Tunisia               Africa     2007    73.9 10276158     7093.\n 4 Mauritius             Africa     2007    72.8  1250882    10957.\n 5 Algeria               Africa     2007    72.3 33333216     6223.\n 6 Egypt                 Africa     2007    71.3 80264543     5581.\n 7 Morocco               Africa     2007    71.2 33757175     3820.\n 8 Sao Tome and Principe Africa     2007    65.5   199579     1598.\n 9 Comoros               Africa     2007    65.2   710960      986.\n10 Mauritania            Africa     2007    64.2  3270065     1803.\n\n\n\nWe use the summarise() function to get the summary statistics. Common statistics include mean, median, standard deviation, minimum, maximum, etc.\n\ngapminder |&gt; \n  summarise(mean_life_exp = mean(lifeExp))\n\n# A tibble: 1 × 1\n  mean_life_exp\n          &lt;dbl&gt;\n1          59.5\n\n\nStandard deviation:\n\ngapminder |&gt; \n  summarise(sd_life_exp = sd(lifeExp))\n\n# A tibble: 1 × 1\n  sd_life_exp\n        &lt;dbl&gt;\n1        12.9\n\n\nYou can get various summary statistics by combing multiple arguments within summarise():\n\ngapminder |&gt; \n  summarise(mean_life_exp = mean(lifeExp),   \n            sd_life_exp = sd(lifeExp),\n            min_life_exp = min(lifeExp),\n            max_life_exp = max(lifeExp))\n\n# A tibble: 1 × 4\n  mean_life_exp sd_life_exp min_life_exp max_life_exp\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1          59.5        12.9         23.6         82.6\n\n\nMagic!\n\nIn many instances we are interested in aggregate statistics, that is, summary statistics by a category. Say you want to group rows by the continent column then get the use summarise() to get average GDP per capita for each continent. This is where the group() function is useful:\n\n## First create a dataframe of the year 2007 only\n\ngapminder_2007 &lt;- gapminder |&gt; \n  filter(year == 2007)\n\n## Then use group_by()\n\ngapminder_2007 |&gt; \n  group_by(continent) |&gt; \n  summarise(gdp_continent = mean(gdpPercap)) |&gt; \n  arrange(desc(gdp_continent))  ## arrange by gdp_continent into descending\n\n# A tibble: 5 × 2\n  continent gdp_continent\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Oceania          29810.\n2 Europe           25054.\n3 Asia             12473.\n4 Americas         11003.\n5 Africa            3089.\n\n\n\nmutate create new columns based on the existing columns. In most cases we want to transform the data. For example, we know that the GDP per capita is calculated from dividing the total GDP by a population. We may want to create a new column named gdp_total with a formula (gdp_total = gdpPercap * pop). We can use mutate():\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(gdp_total = gdpPercap * pop)\n\nhead(gapminder_2007)\n\n# A tibble: 6 × 7\n  country     continent  year lifeExp      pop gdpPercap     gdp_total\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n1 Afghanistan Asia       2007    43.8 31889923      975.  31079291949.\n2 Albania     Europe     2007    76.4  3600523     5937.  21376411360.\n3 Algeria     Africa     2007    72.3 33333216     6223. 207444851958.\n4 Angola      Africa     2007    42.7 12420476     4797.  59583895818.\n5 Argentina   Americas   2007    75.3 40301927    12779. 515033625357.\n6 Australia   Oceania    2007    81.2 20434176    34435. 703658358894.\n\n\nYou can see that the new column named gdp_total has been added.\nYou can also combine multiple arguments within mutate():\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(gdp_total = gdpPercap * pop,\n         life_exp_squared = lifeExp ** 2)\n\n\nThe pipe operator is very useful. You can chain multiple operations into a single code. Let say we want to do the following:\n\nFind country called South Africa\nfind average life expectancy by year\nArrange by year into a descending order\n\n\ngapminder |&gt; \n  filter(country == \"South Africa\") |&gt; \n  group_by(year) |&gt; \n  summarise(life_exp = mean(lifeExp)) |&gt; \n  arrange(desc(year))\n\n# A tibble: 12 × 2\n    year life_exp\n   &lt;int&gt;    &lt;dbl&gt;\n 1  2007     49.3\n 2  2002     53.4\n 3  1997     60.2\n 4  1992     61.9\n 5  1987     60.8\n 6  1982     58.2\n 7  1977     55.5\n 8  1972     53.7\n 9  1967     51.9\n10  1962     50.0\n11  1957     48.0\n12  1952     45.0\n\n\nYou can take it even further by creating a plot. You know that BRICS countries are Brazil, Russia, India, China and South Africa. You want to find trends in life expectancy. Note that there is no data for Russia\n\ngapminder |&gt; \n  filter(country %in% c(\"Brazil\", \"Russia\", \"India\", \"China\", \"South Africa\")) |&gt; \n  select(country, year, lifeExp) |&gt; \n  ggplot(aes(x = year, y = lifeExp, colour = country)) +\n  geom_line(linewidth = 1.5) +\n  theme_minimal() +\n  scale_x_continuous(breaks = c(1950, 1960, 1980, 1990, 2000, 2007)) +\n  theme(legend.position = \"bottom\",\n        panel.grid.minor = element_blank()) +\n  labs(title = \"Trends in life expectancy of BRICS country\",\n       x = \"\",\n       y = \"Life expectancy (in years)\",\n       caption = \"Data source: Gapminder\")\n\n\n\n\nWait a minute: why did south Africa’s life expectancy started to decline rapidly from the 1990s? One plausible reason would be the impact of HIV/AIDS and lack of antiretrovirals (ARVs). Welcome to data analysis.\nYou can see above the efficiency of the pipe operator. Think of the pipe operator as:\n\nOR\n\nWe have introduced to the basics of data manipulation in R using the dplyr package in R. While we have covered a lot, the path is long. However, once you master these basic functions, you will not struggle in the following sections. These resources may be helpful:\n\nR for Data Science. Chapter 4\nData transformation with dplyr"
  },
  {
    "objectID": "weeks/week-3.html#learning-objectives",
    "href": "weeks/week-3.html#learning-objectives",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Understand dataframes\nManipulate, transform and analyse dataframes"
  },
  {
    "objectID": "weeks/week-3.html#introduction",
    "href": "weeks/week-3.html#introduction",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "Dataframes, as we saw the previous section, is a tabular data format, with columns and rows. Columns are variable names and rows are individual observations.\nLet us a basic data frame with three columns: country, life expectancy, and population of Southern African countries. First, we create individual vectors:\n\n# Create a character vector\ncountry_name &lt;- c(\"Angola\", \"Botswana\", \"Lesotho\", \"Malawi\", \"Mozambique\", \"Namibia\", \"South Africa\", \"Swaziland\", \"Zambia\", \"Zimbabwe\")\n\ncountry_name\n\n [1] \"Angola\"       \"Botswana\"     \"Lesotho\"      \"Malawi\"       \"Mozambique\"  \n [6] \"Namibia\"      \"South Africa\" \"Swaziland\"    \"Zambia\"       \"Zimbabwe\"    \n\n## Create a numeric vector\n\nlife_expectancy &lt;- c(61.6, 61.1, 57.1, 53.1, 62.9, 59.3, 59.3, 62.3, 61.2, 59.3)\n\nlife_expectancy\n\n [1] 61.6 61.1 57.1 53.1 62.9 59.3 59.3 62.3 61.2 59.3\n\n## create another numeric vector\n\npopulation &lt;- c(34500000, 2590000, 228000, 19890000, 32080000,  2530000, 59390000, 1190000, 19470000, 1599000)\n\nBecause we have 3 vectors of equal length, we can create a dataframe, using a data.frame() function:\n\nsouthern_africa_df &lt;- data.frame(country_name, life_expectancy, population) #combine two vectors to create a dataframe\n\nsouthern_africa_df ## print the dataframe\n\n   country_name life_expectancy population\n1        Angola            61.6   34500000\n2      Botswana            61.1    2590000\n3       Lesotho            57.1     228000\n4        Malawi            53.1   19890000\n5    Mozambique            62.9   32080000\n6       Namibia            59.3    2530000\n7  South Africa            59.3   59390000\n8     Swaziland            62.3    1190000\n9        Zambia            61.2   19470000\n10     Zimbabwe            59.3    1599000\n\n\nA dataframe is basically made of vectors (columns). In the southern_africa_df dataframe, we have 3 columns: country_name, life_expectancy population. We can extract these elements using the $ sign:\n\nsouthern_africa_df$country_name\n\n [1] \"Angola\"       \"Botswana\"     \"Lesotho\"      \"Malawi\"       \"Mozambique\"  \n [6] \"Namibia\"      \"South Africa\" \"Swaziland\"    \"Zambia\"       \"Zimbabwe\"    \n\nsouthern_africa_df$life_expectancy\n\n [1] 61.6 61.1 57.1 53.1 62.9 59.3 59.3 62.3 61.2 59.3\n\nsouthern_africa_df$population\n\n [1] 34500000  2590000   228000 19890000 32080000  2530000 59390000  1190000\n [9] 19470000  1599000"
  },
  {
    "objectID": "weeks/week-3.html#using-dplyr",
    "href": "weeks/week-3.html#using-dplyr",
    "title": "4 Data Wrangling and Manipulation",
    "section": "",
    "text": "We will use the dplyr package to manipulate data. dplyr is part of tidyverse meta-package and is mostly used to clean, manipulate and transform dataframes. dplyr has 5 main verbs/functions:\n\nselect(): for selecting particular columns in a dataframe\nfilter(): for sub-setting rows based on the specified criteria\narrange(): sort rows/observations based (ascending/descending)\nsummarise(): for summary statistics\nmutate(): create new columns based on the manipulation of the existing columns.\ngroup_by(): get aggregate statistics by a category\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nYou can also load dplyr by loading the tidyverse package; this will load all the packages in in `tidyverse at once. This is useful, for example, when you want to clean and visualise data:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ stringr 1.5.0\n✔ tidyr   1.3.0     ✔ forcats 1.0.0\n✔ readr   2.1.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nNote that you will net to install tidyverse if you did not install it from the previous section:\n\n\nWarning: package 'tidyverse' is in use and will not be installed\n\n\nLet us load the gapminder dataset that we used from the previous week. If you did not install, you will need to do so.\n\nlibrary(gapminder)\n\nThan assign it to the object, gapminder, using the &lt;- operator:\n\ngapminder &lt;- gapminder\n\nWrite the following code to change the country and continent from factor to character, I will explain this in the next chapter:\n\ngapminder$country &lt;- as.character(gapminder$country)\n\ngapminder$continent &lt;- as.character(gapminder$continent)\n\nNow you have an object, which is a dataframe, called gapminder, you can see it in the Environment pane in RStudio. It shows that it has ncol(gapminder) columns/variables and nrow(gapminder) observations/rows\n\n\ngapminder dataframe in Environment pane\n\nYou can use the str() fucntion to get the structure of the dataframe:\n\nstr(gapminder)\n\ntibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n $ country  : chr [1:1704] \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" \"Afghanistan\" ...\n $ continent: chr [1:1704] \"Asia\" \"Asia\" \"Asia\" \"Asia\" ...\n $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ...\n $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n\n\nWe have 6 variables:\n\n“country”\n“continent”\n“year”\n“lifeExp”: life expectancy of a country\n“pop”: population\n“gdpPercap”: GDP per capita\n\nYou can get a sample of the first observations/rows using head() function:\n\nhead(gapminder)\n\n# A tibble: 6 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n6 Afghanistan Asia       1977    38.4 14880372      786.\n\n\n\nWe may be interested in some of the columns in the gampminder dataframe, let say, for example, “country” and “pop” variables and discard others; we use the select() function:\n\nlibrary(dplyr)\nselect(gapminder, \"country\", \"pop\")\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nR return only the country and population variables. select() function only return the variables/columns we are interested in:\n\n\nThe best way to work with R, esepcially tidyverse, is using the pipe (|&gt;) operator. The pipe connect various tasks, for example:\n\ngapminder |&gt;\n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nThe pipe chains your operations. It says:\n\nTake gapminder dataframe\nThen using the select() function to select only pop and country columns\n\nYou will that pipe becomes important when having multiple chains of functions at once.\nYou will notice that in other sources: web, books, etc. have %&gt;% instead of |&gt;. It works the same way. The |&gt; is new. %&gt;% comes from mgttr, an external package, so you needed to load it first before using it. The native pipe |&gt; is built in R, so it there is no need to load it. So, we will stick with the |&gt;.\nIn your RStudio, follow these instructions:\n\nGo to ‘Tools’ and click on ‘Global Options’\nNavigate to ‘Code’ on the left pane\nThen select the fourth option, “use native pipe operator, |&gt;”\nClick ‘Apply’\n\nYou can use the short cut Ctrl + Shift + M If you using Windows to insert the pipe instead of typing it. If you are using Mac, use Cmd + Shift + M.\n\nAs I have said, select() only return the columns specified\n\ngapminder %&gt;% \n  select(country, pop)\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nAlso, notice that we selected “country’ and”pop” columns but did not save them and assigned to an object. To store the results into an object, we have to use assignment operator (&lt;-):\n\ngapminder_selected &lt;- gapminder |&gt;\n  select(country, pop)\n\ngapminder_selected # print\n\n# A tibble: 1,704 × 2\n   country          pop\n   &lt;chr&gt;          &lt;int&gt;\n 1 Afghanistan  8425333\n 2 Afghanistan  9240934\n 3 Afghanistan 10267083\n 4 Afghanistan 11537966\n 5 Afghanistan 13079460\n 6 Afghanistan 14880372\n 7 Afghanistan 12881816\n 8 Afghanistan 13867957\n 9 Afghanistan 16317921\n10 Afghanistan 22227415\n# ℹ 1,694 more rows\n\n\nNow we have saved results as gapminder_selected, and we can do other analysis with this object because we have saved it. So, in a nutshell, when you run a code without assigning results into an object, using the &lt;- operator, results will not be saved but will be printed.\nYou can also select columns based by index/position. Let us select only 1st and 3rd coulmns\n\ngapminder |&gt; \n  select(1, 3)\n\n# A tibble: 1,704 × 2\n   country      year\n   &lt;chr&gt;       &lt;int&gt;\n 1 Afghanistan  1952\n 2 Afghanistan  1957\n 3 Afghanistan  1962\n 4 Afghanistan  1967\n 5 Afghanistan  1972\n 6 Afghanistan  1977\n 7 Afghanistan  1982\n 8 Afghanistan  1987\n 9 Afghanistan  1992\n10 Afghanistan  1997\n# ℹ 1,694 more rows\n\n\nOr you can select a range of columns\n\ngapminder |&gt; \n  select(country:year)\n\n# A tibble: 1,704 × 3\n   country     continent  year\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;\n 1 Afghanistan Asia       1952\n 2 Afghanistan Asia       1957\n 3 Afghanistan Asia       1962\n 4 Afghanistan Asia       1967\n 5 Afghanistan Asia       1972\n 6 Afghanistan Asia       1977\n 7 Afghanistan Asia       1982\n 8 Afghanistan Asia       1987\n 9 Afghanistan Asia       1992\n10 Afghanistan Asia       1997\n# ℹ 1,694 more rows\n\n\nHere, we have select columns from country to year only.\nYou can also exclude certain columns by simply adding the minus (-) sign; let say we want to exclude the gdpPercap from the dataframe\n\ngapminder |&gt; \n  select(-gdpPercap)\n\n# A tibble: 1,704 × 5\n   country     continent  year lifeExp      pop\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;\n 1 Afghanistan Asia       1952    28.8  8425333\n 2 Afghanistan Asia       1957    30.3  9240934\n 3 Afghanistan Asia       1962    32.0 10267083\n 4 Afghanistan Asia       1967    34.0 11537966\n 5 Afghanistan Asia       1972    36.1 13079460\n 6 Afghanistan Asia       1977    38.4 14880372\n 7 Afghanistan Asia       1982    39.9 12881816\n 8 Afghanistan Asia       1987    40.8 13867957\n 9 Afghanistan Asia       1992    41.7 16317921\n10 Afghanistan Asia       1997    41.8 22227415\n# ℹ 1,694 more rows\n\n\n\nYou may be interested in observations/rows that meet certain conditions. We use filter() function to return the list that meet our conditions. filter() has several operators:\n\n==: equal to\n!=: not equal to\n&gt;: greater than\n&lt;: less than\n&gt;=: greater than or equal to\n&lt;=: less than or equal to\n\nLet us filter based on the continent column. How many continent are there? Create a basic table first\n\ntable(gapminder$continent)\n\n\n  Africa Americas     Asia   Europe  Oceania \n     624      300      396      360       24 \n\n\nThere are five continents. Let us filter only observations from the African continent:\n\nafrica_gapminder &lt;- gapminder |&gt; \n  filter(continent == \"Africa\")\n\nafrica_gapminder  # print \n\n# A tibble: 624 × 6\n   country continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;   &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Algeria Africa     1952    43.1  9279525     2449.\n 2 Algeria Africa     1957    45.7 10270856     3014.\n 3 Algeria Africa     1962    48.3 11000948     2551.\n 4 Algeria Africa     1967    51.4 12760499     3247.\n 5 Algeria Africa     1972    54.5 14760787     4183.\n 6 Algeria Africa     1977    58.0 17152804     4910.\n 7 Algeria Africa     1982    61.4 20033753     5745.\n 8 Algeria Africa     1987    65.8 23254956     5681.\n 9 Algeria Africa     1992    67.7 26298373     5023.\n10 Algeria Africa     1997    69.2 29072015     4797.\n# ℹ 614 more rows\n\n\nafrica_gapminder object is a dataframe we have just created, with only countries from the African continent. What filter() does is to return observations/rows that only meet our conditions:\n\nLet us filter a numeric column; for example, we may want to filter countries with population of above 50 million and assign results to an object named high_pop:\n\nhigh_pop &lt;- gapminder |&gt; \n  filter(pop &gt; 50000000)\n\nhigh_pop ## print\n\n# A tibble: 190 × 6\n   country    continent  year lifeExp       pop gdpPercap\n   &lt;chr&gt;      &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n 1 Bangladesh Asia       1957    39.3  51365468      662.\n 2 Bangladesh Asia       1962    41.2  56839289      686.\n 3 Bangladesh Asia       1967    43.5  62821884      721.\n 4 Bangladesh Asia       1972    45.3  70759295      630.\n 5 Bangladesh Asia       1977    46.9  80428306      660.\n 6 Bangladesh Asia       1982    50.0  93074406      677.\n 7 Bangladesh Asia       1987    52.8 103764241      752.\n 8 Bangladesh Asia       1992    56.0 113704579      838.\n 9 Bangladesh Asia       1997    59.4 123315288      973.\n10 Bangladesh Asia       2002    62.0 135656790     1136.\n# ℹ 180 more rows\n\n\nYou can also combine 2 conditions. Let us say we want:\n\ncountries in Africa\nthe year 2007\n\n\nafrica_2007 &lt;- gapminder |&gt; \n  filter(continent == \"Africa\", year == 2007)\n\nFilter rows from the Africa OR Asia\n\ngapminder |&gt; \n  filter(continent == \"Africa\" | continent == \"Asia\")\n\n# A tibble: 1,020 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,010 more rows\n\n\nSometimes you may need to filter multiple rows, let say, more than 5 countries. It would be inconvinient to type country == \"...\" five times. This is where the %in% operator is useful:\n\nafrica_2007 |&gt; \n  filter(country %in% c(\"South Africa\", \"Zimbabwe\", \"Ghana\", \"Tanzania\", \"Tunisia\"))\n\n# A tibble: 5 × 6\n  country      continent  year lifeExp      pop gdpPercap\n  &lt;chr&gt;        &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Ghana        Africa     2007    60.0 22873338     1328.\n2 South Africa Africa     2007    49.3 43997828     9270.\n3 Tanzania     Africa     2007    52.5 38139640     1107.\n4 Tunisia      Africa     2007    73.9 10276158     7093.\n5 Zimbabwe     Africa     2007    43.5 12311143      470.\n\n\n\narrange() function is self-explanatory: it sort values into ascending or descending order\n\nafrica_2007 |&gt; \n  arrange(lifeExp) |&gt; \n  head(n = 10) ## show the first 10 observations\n\n# A tibble: 10 × 6\n   country                  continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;                    &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Swaziland                Africa     2007    39.6  1133066     4513.\n 2 Mozambique               Africa     2007    42.1 19951656      824.\n 3 Zambia                   Africa     2007    42.4 11746035     1271.\n 4 Sierra Leone             Africa     2007    42.6  6144562      863.\n 5 Lesotho                  Africa     2007    42.6  2012649     1569.\n 6 Angola                   Africa     2007    42.7 12420476     4797.\n 7 Zimbabwe                 Africa     2007    43.5 12311143      470.\n 8 Central African Republic Africa     2007    44.7  4369038      706.\n 9 Liberia                  Africa     2007    45.7  3193942      415.\n10 Rwanda                   Africa     2007    46.2  8860588      863.\n\n\nThe default sorting is ascending order; you can sort into descending order by using desc() function within arrange():\n\nafrica_2007 |&gt; \n  arrange(desc(lifeExp)) |&gt; \n  head(n = 10) ## show the first 10 observations\n\n# A tibble: 10 × 6\n   country               continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;                 &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Reunion               Africa     2007    76.4   798094     7670.\n 2 Libya                 Africa     2007    74.0  6036914    12057.\n 3 Tunisia               Africa     2007    73.9 10276158     7093.\n 4 Mauritius             Africa     2007    72.8  1250882    10957.\n 5 Algeria               Africa     2007    72.3 33333216     6223.\n 6 Egypt                 Africa     2007    71.3 80264543     5581.\n 7 Morocco               Africa     2007    71.2 33757175     3820.\n 8 Sao Tome and Principe Africa     2007    65.5   199579     1598.\n 9 Comoros               Africa     2007    65.2   710960      986.\n10 Mauritania            Africa     2007    64.2  3270065     1803.\n\n\n\nWe use the summarise() function to get the summary statistics. Common statistics include mean, median, standard deviation, minimum, maximum, etc.\n\ngapminder |&gt; \n  summarise(mean_life_exp = mean(lifeExp))\n\n# A tibble: 1 × 1\n  mean_life_exp\n          &lt;dbl&gt;\n1          59.5\n\n\nStandard deviation:\n\ngapminder |&gt; \n  summarise(sd_life_exp = sd(lifeExp))\n\n# A tibble: 1 × 1\n  sd_life_exp\n        &lt;dbl&gt;\n1        12.9\n\n\nYou can get various summary statistics by combing multiple arguments within summarise():\n\ngapminder |&gt; \n  summarise(mean_life_exp = mean(lifeExp),   \n            sd_life_exp = sd(lifeExp),\n            min_life_exp = min(lifeExp),\n            max_life_exp = max(lifeExp))\n\n# A tibble: 1 × 4\n  mean_life_exp sd_life_exp min_life_exp max_life_exp\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n1          59.5        12.9         23.6         82.6\n\n\nMagic!\n\nIn many instances we are interested in aggregate statistics, that is, summary statistics by a category. Say you want to group rows by the continent column then get the use summarise() to get average GDP per capita for each continent. This is where the group() function is useful:\n\n## First create a dataframe of the year 2007 only\n\ngapminder_2007 &lt;- gapminder |&gt; \n  filter(year == 2007)\n\n## Then use group_by()\n\ngapminder_2007 |&gt; \n  group_by(continent) |&gt; \n  summarise(gdp_continent = mean(gdpPercap)) |&gt; \n  arrange(desc(gdp_continent))  ## arrange by gdp_continent into descending\n\n# A tibble: 5 × 2\n  continent gdp_continent\n  &lt;chr&gt;             &lt;dbl&gt;\n1 Oceania          29810.\n2 Europe           25054.\n3 Asia             12473.\n4 Americas         11003.\n5 Africa            3089.\n\n\n\nmutate create new columns based on the existing columns. In most cases we want to transform the data. For example, we know that the GDP per capita is calculated from dividing the total GDP by a population. We may want to create a new column named gdp_total with a formula (gdp_total = gdpPercap * pop). We can use mutate():\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(gdp_total = gdpPercap * pop)\n\nhead(gapminder_2007)\n\n# A tibble: 6 × 7\n  country     continent  year lifeExp      pop gdpPercap     gdp_total\n  &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;\n1 Afghanistan Asia       2007    43.8 31889923      975.  31079291949.\n2 Albania     Europe     2007    76.4  3600523     5937.  21376411360.\n3 Algeria     Africa     2007    72.3 33333216     6223. 207444851958.\n4 Angola      Africa     2007    42.7 12420476     4797.  59583895818.\n5 Argentina   Americas   2007    75.3 40301927    12779. 515033625357.\n6 Australia   Oceania    2007    81.2 20434176    34435. 703658358894.\n\n\nYou can see that the new column named gdp_total has been added.\nYou can also combine multiple arguments within mutate():\n\ngapminder_2007 &lt;- gapminder_2007 |&gt; \n  mutate(gdp_total = gdpPercap * pop,\n         life_exp_squared = lifeExp ** 2)\n\n\nThe pipe operator is very useful. You can chain multiple operations into a single code. Let say we want to do the following:\n\nFind country called South Africa\nfind average life expectancy by year\nArrange by year into a descending order\n\n\ngapminder |&gt; \n  filter(country == \"South Africa\") |&gt; \n  group_by(year) |&gt; \n  summarise(life_exp = mean(lifeExp)) |&gt; \n  arrange(desc(year))\n\n# A tibble: 12 × 2\n    year life_exp\n   &lt;int&gt;    &lt;dbl&gt;\n 1  2007     49.3\n 2  2002     53.4\n 3  1997     60.2\n 4  1992     61.9\n 5  1987     60.8\n 6  1982     58.2\n 7  1977     55.5\n 8  1972     53.7\n 9  1967     51.9\n10  1962     50.0\n11  1957     48.0\n12  1952     45.0\n\n\nYou can take it even further by creating a plot. You know that BRICS countries are Brazil, Russia, India, China and South Africa. You want to find trends in life expectancy. Note that there is no data for Russia\n\ngapminder |&gt; \n  filter(country %in% c(\"Brazil\", \"Russia\", \"India\", \"China\", \"South Africa\")) |&gt; \n  select(country, year, lifeExp) |&gt; \n  ggplot(aes(x = year, y = lifeExp, colour = country)) +\n  geom_line(linewidth = 1.5) +\n  theme_minimal() +\n  scale_x_continuous(breaks = c(1950, 1960, 1980, 1990, 2000, 2007)) +\n  theme(legend.position = \"bottom\",\n        panel.grid.minor = element_blank()) +\n  labs(title = \"Trends in life expectancy of BRICS country\",\n       x = \"\",\n       y = \"Life expectancy (in years)\",\n       caption = \"Data source: Gapminder\")\n\n\n\n\nWait a minute: why did south Africa’s life expectancy started to decline rapidly from the 1990s? One plausible reason would be the impact of HIV/AIDS and lack of antiretrovirals (ARVs). Welcome to data analysis.\nYou can see above the efficiency of the pipe operator. Think of the pipe operator as:\n\nOR\n\nWe have introduced to the basics of data manipulation in R using the dplyr package in R. While we have covered a lot, the path is long. However, once you master these basic functions, you will not struggle in the following sections. These resources may be helpful:\n\nR for Data Science. Chapter 4\nData transformation with dplyr"
  },
  {
    "objectID": "weeks/week-5.html",
    "href": "weeks/week-5.html",
    "title": "Importing Data and Reproducible Workflows",
    "section": "",
    "text": "All along we have been working with data stored as packages in R or fake data. But most of the time data is stored locally on our computers either as .csv, Excel, .txt, pdf, etc. There are functions to import these data types, both in Base R and external packages. But first you will need to tell R the location of the data."
  },
  {
    "objectID": "weeks/week-5.html#importing-data",
    "href": "weeks/week-5.html#importing-data",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.1 Importing data",
    "text": "6.1 Importing data\nTo import csv, you can use the read.csv() function. In my case I have dataset saved as “epi_data.csv” in the the folder named “data”:\n\ndata &lt;- read.csv(\"data/epi_data.csv\")\n\nhead(data)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5\n\n\nLet us say te same data is saved in as aan Excel workbook with an extension .xlsx, we can use reaedxl package:\n\ninstall.packages(\"reaedxl\")\n\n\nlibrary(readxl)\n\nWarning: package 'readxl' was built under R version 4.2.2\n\nexcel_data &lt;- read_excel(\"data/epi_data.xlsx\")\n\nhead(excel_data)\n\n# A tibble: 6 × 8\n  country_code country  region population pop_density    GDP epi_score sdg_index\n  &lt;chr&gt;        &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 AFG          Afghani… Asia       34.7          53.1  60.3       37.7      46.8\n2 ALB          Albania  Easte…      2.88        105.   32.7       65.5      68.9\n3 DZA          Algeria  Mid E…     40.6          17.0 565.        57.2      68.8\n4 AGO          Angola   Sub-S…     28.8          23.1 172.        37.4      50.2\n5 ATG          Antigua… Carib…      0.101       229.    2.12      59.2   -9999  \n6 ARG          Argenti… Latin…     43.8          16.0 811.        59.3      72.5\n\n\nThere are other arguments that can be added; for example if you data is on sheet number 2 of Exel workbook, you will add an sheet = 2 argument.\nYou can import data from other statistical software as well:\n\nRead STATA files: STATA data files end with .dta extensions: read_dta() from Haven package can import this data type\nRead SPPS files: SPSS files end with .sav extension: read_sav() function, also from Haven can import it.\n\nR can import other many data types such shapefiles, images, PDFs and data from the web."
  },
  {
    "objectID": "weeks/week-5.html#importing-multiple-files",
    "href": "weeks/week-5.html#importing-multiple-files",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.2 Importing Multiple files",
    "text": "6.2 Importing Multiple files\nSometimes there are many files and it would be time consuming to load each file. I will show you the following with instructions\n\n## First list the path where files are stored\n\npath &lt;- list.files(\"data\", pattern = \".csv$\", full.names = TRUE) \n\n## Read all the files by using lapply function\ndata_files &lt;- lapply(path, read.csv)\n\nnow you have a list with 2 elements. You can extract each element:\n\nfirst_df &lt;- data_files[[1]]\n\nhead(first_df)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5\n\n\n\nsecond_df &lt;- data_files[[2]]\n\nhead(second_df)\n\n      country continent year lifeExp      pop gdpPercap\n1 Afghanistan      Asia 1952  28.801  8425333  779.4453\n2 Afghanistan      Asia 1957  30.332  9240934  820.8530\n3 Afghanistan      Asia 1962  31.997 10267083  853.1007\n4 Afghanistan      Asia 1967  34.020 11537966  836.1971\n5 Afghanistan      Asia 1972  36.088 13079460  739.9811\n6 Afghanistan      Asia 1977  38.438 14880372  786.1134"
  },
  {
    "objectID": "weeks/week-5.html#exporting-data",
    "href": "weeks/week-5.html#exporting-data",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.3 Exporting data",
    "text": "6.3 Exporting data\nAfter you have cleaned and prepared your data for analysis, you may want to save cleaned data.\n\ngapminder &lt;- gapminder::gapminder\n\ngapminder_2007 &lt;- gapminder |&gt; \n  dplyr::filter(year == 2007)\n\nwrite.csv(gapminder_2007, \"data/gapminder_cleaned.csv\")\n\nNot that your my path “data/gapminder_cleaned.csv” will be different yours.\n##6.4 Setting working directories\nWhen working on a project, it may be important to set a working directory, where all you files are stores: data, code, reports, etc. You can use setwd() function. Let’s say we have a folder with all the files:\n\n\nmy_folder\n\ndata\ncode\nreport\n\n\n\nYou will need to set a working directory as:\n\nsetwd(\"C:/Users/mpungosea/my_folder\")\n\nTo navigate to a specific file, you will have to use relative paths. You starting path would be “my_folder”. If you want to load data, you would have to navigate to “data” directory:\n\ndata &lt;- read.csv(\"data/epi_data.csv\")\n\nhead(data)\n\n  country_code             country                   region population\n1          AFG         Afghanistan                     Asia  34.656032\n2          ALB             Albania Eastern Europe & Eurasia   2.876101\n3          DZA             Algeria  Mid East & North Africa  40.606052\n4          AGO              Angola       Sub-Saharan Africa  28.813463\n5          ATG Antigua and Barbuda                Caribbean   0.100963\n6          ARG           Argentina            Latin America  43.847430\n  pop_density        GDP epi_score sdg_index\n1    53.08341  60.287050     37.74      46.8\n2   104.96719  32.669916     65.46      68.9\n3    17.04889 565.284000     57.18      68.8\n4    23.11179 172.438000     37.44      50.2\n5   229.46136   2.121537     59.18   -9999.0\n6    16.02207 810.714000     59.30      72.5"
  },
  {
    "objectID": "weeks/week-5.html#managing-reproducible-workflows",
    "href": "weeks/week-5.html#managing-reproducible-workflows",
    "title": "Importing Data and Reproducible Workflows",
    "section": "6.5 Managing reproducible workflows",
    "text": "6.5 Managing reproducible workflows\nThe problem with the above approach, of setting working directories, is that your directories are local to your computer. We share code with other people: reviewers, team members, etc. We also collaborate with one another. Now imagine that I have “C:/Users/mpungosea/my_folder” as my working directory. Will this work on your computer? NO! In Other instances, you may move files; if you run the code and set the director, R will return an error. This means that your workflows are not reproducible and it is not an efficient way of working.\nEnter RStudio Projects. In Projects, we want to keep all the files that were working with and making it easier to navigate directories and share your work. To start a new project, follow these steps:\n\n\nInside the project, you can add the follwoing directories/folders:\n\ndata: to save all your data files: raw data, cleaned data, analysis data, etc\ncode: save all your scripts: data cleaning, analysis, etc\noutputs: figures, tables, etc\nreports: draft reports final reports, etc\nbibliogaphy: a bibtex file with the list of references.\n\nIn one of my projects, this is how it looks:\n\nEvery time you work on the project, you then open the .Rproj file, it will have all the files associated with the project:"
  }
]